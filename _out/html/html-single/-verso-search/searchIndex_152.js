window.docContents[152].resolve({"/#PSBP-Documentation--Programming-With-Failure--instance-WithFailure-___--_LPAR_validation_RPAR_":{"id":"/#PSBP-Documentation--Programming-With-Failure--instance-WithFailure-___--_LPAR_validation_RPAR_","header":"10.7. instance WithFailure ε  (validation)","context":"PSBP Documentation\u0009Programming With Failure","contents":"What about accumulating exceptions instead of failing fast?\n\nAccumulation is specified using a Monoid type class. For now, the neutral element ν is used, this means that only a\nsemigroup is required instead of a monoid.\n\nclass Monoid (μ : Type) where\n  ν : μ\n  combine : μ → μ → μ\n\nexport Monoid (ν combine)\n\ninfixl:60 \" * \" => combine\n\n\nAccumulation can, for example, be implemented using the List α type.\n\ninstance : Monoid (List α) where\n  ν := []\n  combine := .append\n\n\ninstance\n    [Functor computation] :\n  Functor (FailureT ε computation) where\n    map :=\n     λ αfβ ⟨cεoα⟩ =>\n       ⟨(λ εoα =>\n           match εoα with\n            | .inl ε => .inl ε\n            | .inr α => .inr (αfβ α)) <$> cεoα\n       ⟩\n\ninstance\n    [Applicative computation]\n    [Monoid ε] :\n  Applicative (FailureT ε computation) where\n    pure :=\n      λ α =>\n        ⟨pure $ .inr α⟩\n    seq :=\n      λ ⟨cεoαfβ⟩ ufftεcα =>\n        let cεoα :=\n          (ufftεcα ()).toComputationOfSum\n        let εoαfεoαfβfεoβ {α β : Type} :\n          (ε ⊕ α) → (ε ⊕ (α → β)) → (ε ⊕ β) :=\n            λ εoα εoαfβ =>\n              match εoα with\n                | .inl ε =>\n                  match εoαfβ with\n                    | .inr _  => .inl ε\n                    | .inl ε' => .inl (ε' * ε)\n                | .inr α =>\n                  match εoαfβ with\n                    | .inr αfβ  => .inr (αfβ α)\n                    | .inl ε' => .inl ε'\n        ⟨εoαfεoαfβfεoβ <$> cεoα <*> cεoαfβ⟩\n\n\n"}});