window.docContents[130].resolve({"/#PSBP-Documentation--The--PSBP--library-type-classes--class-Conditional":{"id":"/#PSBP-Documentation--The--PSBP--library-type-classes--class-Conditional","header":"4.5. class Conditional","context":"PSBP Documentation\u0009The  PSBP  library type classes","contents":"Programs can be combined to consume sum values. Only the left one and its effects or right one and its effects is used.\nWe can define programs that consume sum values in a formal way by defining a type class. This is what we do with the\nConditional type class.\n\nclass Conditional\n    (program : Type → Type → Type) where\n  sum {α β γ : Type} :\n    program γ α → program β α → program (γ ⊕ β) α\n\nexport Conditional (sum)\n\ninfixl:55 \" ||| \" => sum\n\n\nsum also has infix notation |||.\n\n"},"/#PSBP-Documentation--Programming-With-Failure--ProgramWithValidation":{"id":"/#PSBP-Documentation--Programming-With-Failure--ProgramWithValidation","header":"13.8. ProgramWithValidation","context":"PSBP Documentation\u0009Programming With Failure","contents":"abbrev ProgramWithValidation ε computation :=\n  FromComputationValuedFunction (FailureT ε computation)\n\ndef materializeWithValidation\n    [Monad computation]\n    [Monoid ε] {α β : Type} :\n  ProgramWithValidation ε computation α β →\n  α →\n  computation (ε ⊕ β) :=\n    λ ⟨αftεcβ⟩ α =>\n      (αftεcβ α).toComputationOfSum\n\ndef materializeActiveWithValidation\n    [Monoid ε] {α β : Type} :\n ProgramWithValidation ε Active α β → α → (ε ⊕ β) :=\n  materializeWithValidation\n\n\ninstance Functor (FailureT ε computation), instance Applicative (FailureT ε computation) and\nmaterializeActiveWithValidation above cause programs to accumulate all exceptions that are encountered.\n\nThe examples below illustrate this accumulation behavior.\n\n"}});