window.docContents[43].resolve({"/#PSBP-Documentation--Creational--theorems":{"id":"/#PSBP-Documentation--Creational--theorems","header":"9. Creational  theorems","context":"PSBP Documentation","contents":"Theorem creational_onlyFirst_asProgram' uses the pure_bind law of LawfulMonad and the map_pure law of\nLawfulApplicative.\n\ntheorem creational_onlyFirst_asProgram'\n  {α β γ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αfβ : α → β) :\n    (onlyFirst (asProgram αfβ) :\n      FromComputationValuedFunction\n        computation (α × γ) (β × γ)) =\n      (asProgram (λ (α, γ) => (αfβ α, γ))) := by\n  calc\n    (onlyFirst (asProgram αfβ))\n        = onlyFirst ⟨λ α => pure $ αfβ α⟩ :=\n        rfl\n    _   = ((first :\n           FromComputationValuedFunction\n             computation (α × γ) α) >=>\n            (⟨λ α => pure $ αfβ α⟩)) &&& second :=\n        rfl\n    _   = (((asProgram λ (α, _) => α) :\n            FromComputationValuedFunction\n              computation (α × γ) α) >=>\n              (⟨λ α => pure $ αfβ α⟩)) &&& second :=\n        rfl\n    _   = ((⟨λ (α, _) => pure α⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) α) >=>\n              (⟨λ α => pure $ αfβ α⟩)) &&& second :=\n        rfl\n    _   = (⟨λ (α, _) => pure α >>= (λ α => pure $ αfβ α)⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&& second :=\n        rfl\n    _   = (⟨(λ (α, _) => pure $ αfβ α)⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&& second :=\n        congrArg\n          (λ (αfcβ : α → computation β) =>\n            ((⟨λ (α, _) => αfcβ α⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&& second))\n          (funext (λ α =>\n            pure_bind α (λ α => pure $ αfβ α)))\n    _   = (⟨λ (α, _) => pure $ αfβ α⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&& second :=\n        rfl\n    _   = (⟨λ (α, _) => pure $ αfβ α⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&&\n              (asProgram (λ (_, γ) => γ) :\n                FromComputationValuedFunction\n                  computation (α × γ) γ) :=\n        rfl\n    _   = (⟨λ (α, _) => pure $ αfβ α⟩ :\n            FromComputationValuedFunction\n              computation (α × γ) β) &&&\n              (⟨λ (_, γ) => pure $ γ⟩ :\n                FromComputationValuedFunction\n                  computation (α × γ) γ) :=\n        rfl\n    _   = (⟨λ (α, γ) =>\n            (Prod.mk <$> (pure $ αfβ α)) <*> (pure $ γ)⟩ :\n             FromComputationValuedFunction\n               computation (α × γ) (β × γ)) :=\n        rfl\n    _   = (⟨λ (α, γ) =>\n            (pure $ Prod.mk (αfβ α)) <*> (pure $ γ)⟩ :\n             FromComputationValuedFunction\n             computation (α × γ) (β × γ)) :=\n        congrArg\n         (FromComputationValuedFunction.mk ∘\n           ((λ αfβaγ =>\n             λ (α, γ) => αfβaγ α <*> (pure $ γ)) :\n             (α → computation (γ → (β × γ))) →\n               ((α × γ) → computation (β × γ))))\n          (funext λ α => (map_pure (Prod.mk) (αfβ α)))\n    _   = (⟨λ (α, γ) => Prod.mk (αfβ α) <$> (pure $ γ)⟩) :=\n        congrArg\n         FromComputationValuedFunction.mk\n          (funext λ (α, γ) =>\n            (pure_seq (Prod.mk (αfβ α)) (pure $ γ)))\n    _   = (⟨λ (α, γ) => pure (Prod.mk (αfβ α) γ)⟩) :=\n        congrArg\n         FromComputationValuedFunction.mk\n          (funext λ (α, γ) =>\n            (map_pure (Prod.mk (αfβ α)) γ))\n    _   = (⟨λ (α, γ) => pure $ (αfβ α, γ)⟩) :=\n        rfl\n    _   = (asProgram (λ (α, γ) => (αfβ α, γ))) :=\n        rfl\n\n\nTheorem creational_onlyFirst_asProgram uses simp to let Lean do the heavy lifting\n\n@[simp] theorem creational_onlyFirst_asProgram\n  {α β γ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αfβ : α → β) :\n    (onlyFirst (asProgram αfβ) :\n      FromComputationValuedFunction\n        computation (α × γ) (β × γ)) =\n      (asProgram (λ (α, γ) => (αfβ α, γ))) := by simp [\n        onlyFirst, asProgram, product, first, second\n        ]\n\n\nBy now you probably agree that calc based proofs can become tedious.\n\nIn what follows, I will, mostly, only show the simp based proofs.\n\n@[simp] theorem creational_onlyFirst_sequential\n  {α β γ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β)\n  (βpγ : FromComputationValuedFunction computation β γ) :\n    (onlyFirst (αpβ >=> βpγ) :\n      FromComputationValuedFunction\n        computation (α × δ) (γ × δ)) =\n      (onlyFirst αpβ >=> onlyFirst βpγ :\n        FromComputationValuedFunction\n          computation (α × δ) (γ × δ)) := by simp[\n            onlyFirst, andThen, asProgram, product, first,\n            second\n            ]\n\n\n@[simp] theorem creational_onlyFirst_first\n  {α β γ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    (onlyFirst αpβ >=> first :\n      FromComputationValuedFunction computation (α × γ) β) =\n      (first >=> αpβ) := by simp[\n        onlyFirst, andThen, asProgram, product, first,\n        second\n        ]\n\n\n@[simp] theorem creational_onlyFirst_applyAtSecond\n  {α β γ δ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β)\n  (γfδ : γ → δ) :\n    (onlyFirst αpβ >=> applyAtSecond γfδ) =\n      (applyAtSecond γfδ >=> onlyFirst αpβ) := by simp[\n        onlyFirst, andThen, applyAtSecond, asProgram,\n        product, first, second\n        ]\n\n\n@[simp] theorem creational_onlyFirst_assoc\n  {α β γ δ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    (onlyFirst (onlyFirst αpβ) >=> assoc :\n      FromComputationValuedFunction\n        computation ((α × γ) × δ) (β × (γ × δ))) =\n      (assoc >=> onlyFirst αpβ) := by simp[\n        onlyFirst, andThen, asProgram, product, first,\n        second, assoc\n        ]\n\n\n\n\n"}});