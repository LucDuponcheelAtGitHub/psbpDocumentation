window.docContents[134].resolve({"/#PSBP-Documentation--fibonacci--and--factorial--def-if_":{"id":"/#PSBP-Documentation--fibonacci--and--factorial--def-if_","header":"5.2. def if_","context":"PSBP Documentation\u0009fibonacci  and  factorial","contents":"Using the if_ combinator conditional boolean logic can be expressed. A helper function and corresponding program is\nneeded to define it.\n\ndef if_\n    [Functional program]\n    [Sequential program]\n    [Creational program]\n    [Conditional program] :\n  program α Bool →\n  program α β →\n  program α β →\n  program α β :=\n    λ αpb t_apβ f_apβ =>\n      let_ αpb $\n        in_ $\n          asProgram (\n            λ αab => match αab with\n              | ⟨α, true⟩ => .inl α\n              | ⟨α, false⟩ => .inr α\n          ) >=>\n          t_apβ ||| f_apβ\n\ndef else_ : α → α := id\n\n\nFor readability and reusability reasons it is useful to first define some primitive functions\n\ndef isZeroF: Nat → Bool :=\n  λ n => n == 0\n\ndef isOneF : Nat → Bool :=\n  λ n => n == 1\n\ndef oneF : Nat → Nat :=\n  λ _ => 1\n\ndef minusOneF : Nat → Nat :=\n  λ n => n - 1\n\ndef minusTwoF : Nat → Nat :=\n  λ n => n - 2\n\ndef addF : Nat × Nat → Nat :=\n  λ ⟨n, m⟩ => n + m\n\ndef multiplyF : Nat × Nat → Nat :=\n  λ ⟨n, m⟩ => n * m\n\n\nand corresponding primitive programs\n\ndef isZero\n    [Functional program] :\n  program Nat Bool :=\n    asProgram isZeroF\n\ndef isOne\n    [Functional program] :\n  program Nat Bool :=\n    asProgram isOneF\n\ndef one\n    [Functional program] :\n  program Nat Nat :=\n    asProgram oneF\n\ndef minusOne\n    [Functional program] :\n  program Nat Nat :=\n    asProgram minusOneF\n\ndef minusTwo\n    [Functional program] :\n  program Nat Nat :=\n    asProgram minusTwoF\n\ndef add\n    [Functional program] :\n  program (Nat × Nat) Nat :=\n    asProgram addF\n\ndef multiply\n    [Functional program] :\n  program (Nat × Nat) Nat :=\n    asProgram multiplyF\n\n\nProgram fibonacci is defined as follows\n\nunsafe def fibonacci\n    [Functional program]\n    [Creational program]\n    [Sequential program]\n    [Conditional program] :\n  program Nat Nat :=\n    if_ isZero one $\n      else_ $\n        if_ isOne one $\n          else_ $\n            (minusOne >=> fibonacci) &&&\n            (minusTwo >=> fibonacci) >=>\n            add\n\n\nProgram factorial is defined as follows\n\nunsafe def factorial\n    [Functional program]\n    [Creational program]\n    [Sequential program]\n    [Conditional program] :\n  program Nat Nat :=\n    if_ isZero one $\n      else_ $\n        let_ (minusOne >=> factorial) $\n          in_ $\n            multiply\n\n\nThe unsafe keyword is used because the definitions above do not type check without them. fibonacci and factorial\nare program specifications, they need to be materialized before they can be used. It is instructive to compare this with\nthe painting \"Ceci n'est pas une pipe\" of René Magritte. Much\nin the same way, descriptions of effects are, luckily enough, also not side effects. So it is safe to hang a picture of\na bomb explosion on your wall.The painting is, of course, not a pipe, it is a description of a pipe. A specification is\nalso a (special kind of) description.\n\n"}});