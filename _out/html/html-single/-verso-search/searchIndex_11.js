window.docContents[11].resolve({"/#PSBP-Documentation--Positional-Programming--Using--Functorial":{"id":"/#PSBP-Documentation--Positional-Programming--Using--Functorial","header":"9.1. Using  Functorial","context":"PSBP Documentation\u0009Positional Programming","contents":"Pointfree programming, like is done for fibonacci and factorial may be a elegant, but PSBP also enables, and,\nfor reasons of elegance, sometimes needs, positional programming. Let's first start with Functorial based positional\nprogramming. Suppose we want to run the function that transforms an initial (argument) value n of type Nat to the\nfinal (result) value (((n-1, n-2), 2), 3) => (n-2) + 2 * (n-1) + 3. someProgram01 below could be a solution.\nsomeProgram01 makes use of Functorial.\n\nLet\n\ndef twoF : Nat → Nat := λ _ => 2\n\ndef threeF : Nat → Nat := λ _ => 3\n\n\nand\n\ndef two [Functional program] :\n  program Nat Nat :=\n    asProgram twoF\n\ndef three [Functional program] :\n  program Nat Nat :=\n    asProgram threeF\n\n\nin\n\ndef someProgram01\n    [Functional program]\n    [Functorial program]\n    [Creational program] :\n  program Nat Nat :=\n    minusOne &&& minusTwo &&& two &&& three >->\n      λ (((n1, n2), n3), n4) =>\n        n2 + n3 * n1 + n4\n\n\n#eval\n  materializeActive\n  someProgram01\n  10\n\n\n29\n\n\n#eval\n  materializeReactive\n  someProgram01\n  10\n\n\n29\n\n\nYou may argue that, as for as the acting function involved is concerned, we are back to pointful programming. Well,\nsomehow you are right, but notice that all n's involved have indices (1, 2, 3 and 4). They can be thought of\nas positions. So we are essentially accessing values at positions of multi-values. For this example the multi-value\ninvolved is homogeneous but it might as well be a heterogeneous one. More about this later.\n\n"}});