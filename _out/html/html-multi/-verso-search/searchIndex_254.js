window.docContents[254].resolve({"/fibonacci--and--factorial/factorial/#PSBP-Documentation--fibonacci--and--factorial--factorial":{"id":"/fibonacci--and--factorial/factorial/#PSBP-Documentation--fibonacci--and--factorial--factorial","header":"5.5. factorial","context":"PSBP Documentation\u0009fibonacci  and  factorial","contents":"Program factorial is defined as follows\n\nunsafe def factorial\n    [Functional program]\n    [Creational program]\n    [Sequential program]\n    [Conditional program] :\n  program Nat Nat :=\n    if_ isZero one $\n      else_ $\n        let_ (minusOne >=> factorial) $\n          in_ $\n            multiply\n\n\nThe unsafe keyword is used because the definitions above do not type check without them. fibonacci and factorial\nare program specifications, they need to be materialized before they can be used. It is instructive to compare this with\nthe painting \"Ceci n'est pas une pipe\" of René Magritte. Much\nin the same way, descriptions of effects are, luckily enough, also not side effects. So it is safe to hang a picture of\na bomb explosion on your wall.The painting is, of course, not a pipe, it is a description of a pipe. A specification is\nalso a (special kind of) description.\n\n"},"/Programming-With-State/ProgramWithState/#PSBP-Documentation--Programming-With-State--ProgramWithState":{"id":"/Programming-With-State/ProgramWithState/#PSBP-Documentation--Programming-With-State--ProgramWithState","header":"12.4. ProgramWithState","context":"PSBP Documentation\u0009Programming With State","contents":"abbrev ProgramWithState σ computation :=\n  FromComputationValuedFunction (StateT σ computation)\n\ndef materializeWithState\n    [Monad computation] {α β : Type} :\n  ProgramWithState σ computation α β →\n  α →\n  σ →\n  computation β :=\n    λ ⟨αfstσcβ⟩ =>\n      λ α =>\n        λ σ =>\n          StateT.run (αfstσcβ α) σ >>=\n            λ (β, _) => pure β\n\ndef materializeActiveWithState {α β : Type} :\n  ProgramWithState σ Active α β → α → σ → β :=\n    materializeWithState\n\n\n"},"/Programming-With-Failure/WithFailure-___/#PSBP-Documentation--Programming-With-Failure--WithFailure-___":{"id":"/Programming-With-Failure/WithFailure-___/#PSBP-Documentation--Programming-With-Failure--WithFailure-___","header":"13.1. WithFailure ε","context":"PSBP Documentation\u0009Programming With Failure","contents":"PSBP enables programming with failure using the WithFailure class below.\n\nclass WithFailure\n    (ε : outParam Type)\n    (program : Type → Type →Type) where\n  failureWith {α β : Type} : (α → ε) → program α β\n\nexport WithFailure (failureWith)\n\n\n"}});