window.docContents[173].resolve({"/ReactiveProgram/#PSBP-Documentation--ReactiveProgram":{"id":"/ReactiveProgram/#PSBP-Documentation--ReactiveProgram","header":"10. ReactiveProgram","context":"PSBP Documentation","contents":"There is much more work to be done for reactive implementations. They are callback handler, a.k.a. continuation based.\n\nstructure ReactiveT\n    (ρ : Type)\n    (computation: Type → Type)\n    (α : Type) where\n  runReactiveT : (α → computation ρ) → computation ρ\n\nabbrev Reactive ρ := ReactiveT ρ Active\n\ninstance {ρ: Type} :\n    Functor (ReactiveT ρ computation) where\n  map :=\n    λ αfβ ⟨rcα⟩ =>\n      ⟨λ γ => rcα (γ ∘ αfβ)⟩\n\ninstance {ρ: Type} :\n    Applicative (ReactiveT ρ computation) where\n  pure := λ α => ReactiveT.mk (λ αfcρ => αfcρ α)\n  seq :=\n    λ ⟨rcαfβ⟩ ufrtρcα =>\n      ⟨λ βfcρ =>\n        rcαfβ $\n          (λ αfβ =>\n            (ufrtρcα ()).runReactiveT (βfcρ ∘ αfβ))⟩\n\ninstance {ρ: Type} :\n    Monad (ReactiveT ρ computation) where\n  bind :=\n    λ ⟨rcα⟩ αfrtρcβ =>\n      ⟨λ βfcρ =>\n        rcα (λ α =>\n        (αfrtρcβ α).runReactiveT βfcρ)⟩\n\nabbrev ReactiveProgram ρ computation :=\n  FromComputationValuedFunction (ReactiveT ρ computation)\n\ndef materializeReactive {α β : Type} :\n    ReactiveProgram β Active α β → α → β :=\n  λ ⟨αfrtaβcβ⟩ α =>\n      (αfrtaβcβ α).runReactiveT id\n\n\nThe ρ stands for the \"result\" of callback handling.\n\nWe can now run our programs in a reactive way.\n\n#eval\n  materializeReactive\n  fibonacci\n  10\n\n\n89\n\n\n#eval\n  materializeReactive\n  factorial\n  10\n\n\n3628800\n\n\n#eval\n  materializeReactive\n  twiceMinusOne01\n  10\n\n\n18\n\n\n#eval\n  materializeReactive\n  twiceMinusOne02\n  10\n\n\n18\n\n\nWe did not change the definition of our programs, we only materialized them in another way!\n\n"}});