window.docContents[189].resolve({"/My-history-related-to-Functional-Programming/#PSBP-Documentation--My-history-related-to-Functional-Programming":{"id":"/My-history-related-to-Functional-Programming/#PSBP-Documentation--My-history-related-to-Functional-Programming","header":"2. My history related to Functional Programming","context":"PSBP Documentation","contents":"I am a mathematician.\n\nI did mathematics research on\nNon-archimedean induced representations of compact zerodimensional groups.\n\nThat being said, I soon realized that, those days, in Belgium, mathematics could mainly be done as a backyard ritual,\nso, in order to earn some money for a living, I decided to become a programmer. I started doing computer science\nresearch as a late at night hobby. As such, I naturally became interested in the theory of functional programming.\n\nI studied function level programming systems, as implemented in\nFP programming system.\n\nI also studied a book about acceptable programming systems. I cannot easily find a reference to it.\n\nAnyway, the latter study culminated in a paper\nAcceptable functional programming systems,\nwritten together with my twin brother Marc, who is also a mathematician. Among others, the paper illustrated acceptable\nfunctional programming systems using code written using the\nPascal programming language). Those days, the Pascal\nprogramming language already, somehow, partially supported functional programming.\n\nBoth acceptable functional programming systems and function level programming systems are examples of pointfree\neffectfree functional programming systems.\n\nThe first functional programming language I used was\nMiranda). Miranda was, and still is, a perfect language\nto start learning effectfree functional programming with.\n\nBut programming is also about effectful programming ... .\n\nThe next functional programming language I used was\nGofer). Gofer was the first functional programming language\nsupporting type constructor classes. That capability of Gofer was, for me, the very reason to use it. I wanted to\nwrite code using with category theory related concepts, to deal with side effects.\n\nThis culminates in papers\n\n1. Composing monads,2. On the expressive power of Constructor Classes,3. Deterministic, Error-Correcting Combinator Parsers, and4. Using catamorphisms, subtypes and monad transformers for writing modular functional interpeters.\n\nThe first paper was, as a late night hobby, written together with Mark P. Jones, the author of Gofer. What is special\nabout that paper is that we had never physically met each other. Those were the early days of the internet. We wrote\nthe paper (and the code that came with it) together by sending emails to each other. In fact, it turned out to be an\nefficient way to work together. While one of us was sleeping (in Europe resp. the United States of America) the other\none was working (in the United States of America resp. Europe). The paper also contained proofs. Those days they were\nsimply lists of expressions representing equetional reasoning steps.\n\nThe other papers were written whilst working two years at the University of Utrecht. A unique experience for me for\nwhich I am forever greatful to Doaitse Swierstrsa (†), and Erik Meijer, who introduced me to Doaitse. Apart from being\nan exceptional computer scientist, Doaitse was the best manager I have ever worked with. Erik does not need any\nintroduction. He is a living legend. Also Grahan Hutton worked at the University of Utrecht those days. What a team!\n\nThe second paper was written together with Erik Meijer and was presented at a conference in Glasgow, those days, and\nstill today, an important centre of functional programming (cfr. Philip Wadler and Simon Peyton Jones).\n\nThe third paper was written together with Doaitse Swierstra and turned out to be a motivation for two monad\nspecification related specifications:\nProgramming with Arrows and\nApplicative Programming with Effects.\n\nThe fourth paper has never been published. It was based on\nMonad transformers and modular interpreters.\nI used catamorphisms and subtypes for making interpreter fragments more reusable. Anyway, the paper, somehow, turned\nout to be available online and has been cited several times.\n\nThe monad specification and applicative specification are examples of pointful effectful functional programming related\nspecifications. The arrow specification is an example of a pointfree effectful functional programming related\nspecification.\n\nThe program specification of this document is a pointfree effectful functional programming related specification that\nis similar to, but more powerful than the arrow specification. Think of programs as arrows with alternatives.\n\nAll this brings me to the motivation of this document.\n\nThe functor, applicative and monad specifications specify computation capabilities. Think of computations as effectful\nexpressions. They are operational artifacts. They do not really have a meaning in the mathematical sense. Functions, on\nthe other hand, are denotational artifacts. They do have a meaning in the mathematical sense. This document refers to\neffectful function specifications as program specifications, specifying program capabilities. Think of programs as\neffectful functions. They are denotational artifacts. They have a meaning in the mathematical sense.\n\nIn my opinion it is, as a programmer, more natural to think denotationally (what) than to think operationally (how).\n\nLet's try to illustste this with some Lean code.\n\nThe computation related type class Bind has a member\n\nbind :\n  {α β : Type} →\n  computation α → (α → computation β) → computation β\n\n\nwith law (>>= is infix for bind)\n\nbind_assoc\n  (cα : computation α)\n  (αfcβ : α → computation β)\n  (βfcγ : β → computation γ) :\n    cα >>= αfcβ >>= βfcγ = cα >>= λ α => αfcβ α >>= βfcγ\n\n\nThe program related type class Sequential has a member\n\nandThen\n  {α β γ : Type} :\n  program α β → program β γ → program α γ\n\n\nwith law (>=> is infix for andThen)\n\nandThen_assoc\n  (αpβ : program α β)\n  (βpγ : program β γ)\n  (γpδ : program γ δ) :\n  ((αpβ >=> βpγ) >=> γpδ) = (αpβ >=> (βpγ >=> γpδ))\n\n\nFrom a syntax point of view, I think that the Sequential member and law is more elegant than the Bind mamber and law.\nFrom a semantic point of view, how to explain bind and bind_assoc, and how to explain andThen and andThen_assoc?\n\nLet's first deal with Sequential. I think of a program as transforming an argument to a result. andThen can be\nexplained as: if you can transform argument α to result β, and you can transform argument β to result γ, then\nyou can transform argument α to result γ. andThen_assoc can be explained as: first transforming argument α to\nintermediate result γ using αpβ >=> βpγ, and then transforming argument γ to final result δ using γpδ which is\nthe same as the final result obtained by first transforming argument α to intermediate result β using αpβ, and\nthen transforming argument β using βpγ >=> γpδ. Hopefully this is a meaningful denotational explanation.\n\nLet's second deal with Bind. I think of a computation as, when executing it, yielding a result. bind can be\nexplained as: binding result α, yielded by executing inner computation cα, to outer computation valued function\nαfcβ, yields outer computation cβ (that, when executing it, yields result β). bind_assoc can be explained as\nbinding result α yielded by executing inner computation cα, to intermediate computation valued function αfcβ,\nyielding intermediate computation result cβ that, when executing it, yields intermediate result β that, when binding\nit to outer computation valued function βfcγ, yields outer computation result cγ which is the same as the outer\ncomputation result obtained by binding result α yielded by executing inner computation cα to the outer computation\nvalued function binding α to the computation result obtained by binding result β, yielded by executing intermediate\ncomputation result αfcβ α to outer computation valued function βfcγ. Hopefully this is a meaningful operational\nexplanation.\n\nLet's face it, the denotational explanations are more elegant than the operational ones.\n\n"}});