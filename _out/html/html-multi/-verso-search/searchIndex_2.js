window.docContents[2].resolve({"/Programming-With-Failure/instance-WithFailure-___/#PSBP-Documentation--Programming-With-Failure--instance-WithFailure-___":{"id":"/Programming-With-Failure/instance-WithFailure-___/#PSBP-Documentation--Programming-With-Failure--instance-WithFailure-___","header":"11.2. instance WithFailure ε","context":"PSBP Documentation\u0009Programming With Failure","contents":"WithFailure ε is implemented in terms of FailureT, which is defined in terms of ⊕. Given an initial (argument)\nvalue, a program with failure may transform it to a final failure (result) value (at left) or a final succedd (result)\nvalue (at right).\n\ndef FailureT\n    (ε : Type u)\n    (computation : Type u → Type v)\n    (β : Type u) : Type v :=\n  computation (ε ⊕ β)\n\ndef FailureT.mk\n    {ε : Type u}\n    {computation : Type u → Type v}\n    {α : Type u}\n    (cεoα : computation (ε ⊕ α)) :\n  FailureT ε computation α := cεoα\n\ninstance [Monad computation] :\n    Monad (FailureT ε computation) where\n  map  :=\n  λ αfβ ftcα =>\n    .mk (ftcα >>= λ εoα => match εoα with\n      | (Sum.inr α) => pure $ Sum.inr (αfβ α)\n      | (Sum.inl ε) => pure $ Sum.inl ε)\n  pure :=\n    λ α =>\n      .mk (pure (Sum.inr α))\n  bind :=\n  λ ftcα αfftcβ =>\n    .mk (ftcα >>= λ εoα => match εoα with\n      | Sum.inr α  => αfftcβ α\n      | Sum.inl ε  => pure (Sum.inl ε))\n\ninstance {ε : Type} [Applicative computation] :\n    WithFailure ε\n      (FromComputationValuedFunction\n        (FailureT ε computation)) where\n  failWith :=\n    λ αfε =>\n      ⟨λ α =>\n        let cεpβ :=\n          pure  $\n            Sum.inl $\n              αfε α\n        cεpβ⟩\n\n\n"}});