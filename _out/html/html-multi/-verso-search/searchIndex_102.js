window.docContents[102].resolve({"/Theorems/Sequential--theorems/#PSBP-Documentation--Theorems--Sequential--theorems":{"id":"/Theorems/Sequential--theorems/#PSBP-Documentation--Theorems--Sequential--theorems","header":"8.3. Sequential  theorems","context":"PSBP Documentation\u0009Theorems","contents":"Theorem sequential_right_identity' uses the bind_pure_comp law of LawfulMonad and the comp_map law of\nLawfulFunctor.\n\ntheorem sequential_right_identity'\n  {α β : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    (αpβ >=> asProgram id :\n      FromComputationValuedFunction computation α β)\n    = αpβ := by\n   let αfcβ := αpβ.toComputationValuedFunction\n   calc\n      (αpβ >=> asProgram id :\n          FromComputationValuedFunction computation α β)\n          = ⟨λ α => αfcβ α >>= λ β => pure (id β)⟩\n            := rfl\n      _   = ⟨λ α => id <$> αfcβ α⟩\n            := congrArg\n                 FromComputationValuedFunction.mk\n                 (funext λ α => bind_pure_comp id (αfcβ α))\n      _   = ⟨λ α => αfcβ α⟩\n            := congrArg\n                 FromComputationValuedFunction.mk\n                 (funext λ α => id_map (αfcβ α))\n      _   = αpβ\n            := rfl\n\n\nTheorem sequential_right_identity uses simp to let Lean do the heavy lifting\n\n@[simp] theorem sequential_right_identity\n  {α β : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    ((αpβ >=> asProgram id) :\n      FromComputationValuedFunction computation α β)\n      = αpβ := by simp[andThen]\n\n\nTheorem sequential_left_identity' uses the pure_bind law of LawfulMonad.\n\n@[simp] theorem sequential_left_identity'\n  {α β : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    (asProgram id >=> αpβ :\n      FromComputationValuedFunction computation α β)\n    = αpβ := by\n    let αfcβ := αpβ.toComputationValuedFunction\n    calc\n      (asProgram id >=> ⟨αfcβ⟩ :\n        FromComputationValuedFunction computation α β)\n          = ⟨λ α => pure α >>= αfcβ⟩\n            := rfl\n      _   = ⟨λ α => αfcβ α⟩\n            := congrArg\n                 FromComputationValuedFunction.mk\n                 (funext λ α => pure_bind α αfcβ)\n      _   = ⟨αfcβ⟩\n            := rfl\n\n\nTheorem sequential_left_identity uses simp to let Lean do the heavy lifting\n\n@[simp] theorem sequential_left_identity\n  {α β : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n    (asProgram id >=> αpβ :\n      FromComputationValuedFunction computation α β)\n    = αpβ := by simp[andThen]\n\n\nTheorem sequential_associative' uses the pure_assoc law of LawfulMonad.\n\n@[simp] theorem sequential_associative'\n  {α β γ δ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β)\n  (βpγ : FromComputationValuedFunction computation β γ)\n  (γpδ : FromComputationValuedFunction computation γ δ) :\n    ((αpβ >=> βpγ) >=> γpδ :\n      FromComputationValuedFunction computation α δ) =\n      (αpβ >=> (βpγ >=> γpδ)) := by\n  let αfcβ : α → computation β :=\n    αpβ.toComputationValuedFunction\n  let βfcγ : β → computation γ :=\n    βpγ.toComputationValuedFunction\n  let γfcδ : γ → computation δ :=\n    γpδ.toComputationValuedFunction\n  let βfcδ : β → computation δ :=\n    λ β => βfcγ β >>= γfcδ\n  calc\n    ((αpβ >=> βpγ) >=> γpδ :\n      FromComputationValuedFunction computation α δ)\n        = (⟨λ α => αfcβ α >>= βfcγ⟩ >=> ⟨γfcδ⟩)\n          := rfl\n    _   = ⟨λ α => αfcβ α >>= βfcγ >>= γfcδ⟩\n          := rfl\n    _   = ⟨λ α => αfcβ α >>= (λ β => βfcγ β >>= γfcδ)⟩\n          := congrArg\n               FromComputationValuedFunction.mk\n               (funext λ α => bind_assoc (αfcβ α) βfcγ γfcδ)\n    _   = (⟨λ α => αfcβ α >>= βfcδ⟩ :\n            FromComputationValuedFunction computation α δ)\n          := rfl\n    _   = (αpβ >=> (βpγ >=> γpδ):\n            FromComputationValuedFunction computation α δ)\n          := rfl\n\n\nTheorem sequential_associative uses simp to let Lean do the heavy lifting\n\n@[simp] theorem sequential_associative\n  {α β γ δ : Type}\n    [Monad computation]\n    [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β)\n  (βpγ : FromComputationValuedFunction computation β γ)\n  (γpδ : FromComputationValuedFunction computation γ δ) :\n    ((αpβ >=> βpγ) >=> γpδ :\n      FromComputationValuedFunction computation α δ) =\n      (αpβ >=> (βpγ >=> γpδ)) := by simp[andThen]\n\n\n"}});