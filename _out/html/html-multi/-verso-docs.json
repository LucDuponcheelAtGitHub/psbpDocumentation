{"99":
 "<code>FromComputationValuedFunction (computation : Type → Type) (α β : Type) : Type</code>",
 "98":
 "<code>LawfulConditional.conditional_right {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Conditional program} [self : LawfulConditional program] {γ α β : Type}\n  (γpα : program γ α) (βpα : program β α) : (right &gt;=&gt; γpα ||| βpα) = βpα</code>",
 "97": "<code>program β α</code>",
 "96": "<code>program γ α</code>",
 "95":
 "<code>LawfulConditional.conditional_left {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Conditional program} [self : LawfulConditional program] {γ α β : Type}\n  (γpα : program γ α) (βpα : program β α) : (left &gt;=&gt; γpα ||| βpα) = γpα</code>",
 "94":
 "<code>LawfulConditional (program : Type → Type → Type) [Functional program] [Sequential program] [Conditional program] : Prop</code>",
 "93":
 "<code>right {program : Type → Type → Type} {β γ : Type} [Functional program] : program β (γ ⊕ β)</code>",
 "92":
 "<code>left {program : Type → Type → Type} {γ β : Type} [Functional program] : program γ (γ ⊕ β)</code>",
 "91":
 "<code>LawfulCreational.creational_onlyFirst_assoc {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Creational program} [self : LawfulCreational program] {α β γ δ : Type}\n  (αpβ : program α β) : (onlyFirst (onlyFirst αpβ) &gt;=&gt; assoc) = (assoc &gt;=&gt; onlyFirst αpβ)</code>",
 "90":
 "<code>LawfulCreational.creational_onlyFirst_applyAtSecond {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Creational program} [self : LawfulCreational program] {α β γ δ : Type}\n  (αpβ : program α β) (γfδ : γ → δ) : (onlyFirst αpβ &gt;=&gt; applyAtSecond γfδ) = (applyAtSecond γfδ &gt;=&gt; onlyFirst αpβ)</code>",
 "9": "<code>Sequential (program : Type → Type → Type) : Type 1</code>",
 "89":
 "<code>LawfulCreational.creational_onlyFirst_first {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Creational program} [self : LawfulCreational program] {α β γ : Type}\n  (αpβ : program α β) : (onlyFirst αpβ &gt;=&gt; first) = (first &gt;=&gt; αpβ)</code>",
 "88":
 "<code>LawfulCreational.creational_onlyFirst_sequential {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Creational program} [self : LawfulCreational program] {α β γ δ : Type}\n  (αpβ : program α β) (βpγ : program β γ) : onlyFirst (αpβ &gt;=&gt; βpγ) = (onlyFirst αpβ &gt;=&gt; onlyFirst βpγ)</code>",
 "87":
 "<code>LawfulCreational.creational_onlyFirst_asProgram {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} {inst✝² : Creational program} [self : LawfulCreational program] {α β γ : Type}\n  (αfβ : α → β) : onlyFirst (asProgram αfβ) = applyAtFirst αfβ</code>",
 "86":
 "<code>LawfulCreational (program : Type → Type → Type) [Functional program] [Sequential program] [Creational program] : Prop</code>",
 "85": "<code>γ</code>",
 "84": "<code>β</code>",
 "83": "<code>α</code>",
 "82":
 "<code>assoc {program : Type → Type → Type} {α β γ : Type} [Functional program] : program ((α × β) × γ) (α × β × γ)</code>",
 "81":
 "<code>onlyFirst {program : Type → Type → Type} {α β γ : Type} [Functional program] [Creational program] [Sequential program] :\n  program α β → program (α × γ) (β × γ)</code>",
 "80":
 "<code>second {program : Type → Type → Type} {α β : Type} [Functional program] : program (α × β) β</code>",
 "8":
 "<code><span class=\"literal string\">\" &gt;-&gt; \"</span> : String</code>",
 "79":
 "<code>first {program : Type → Type → Type} {α β : Type} [Functional program] : program (α × β) α</code>",
 "78": "<code>β✝ → γ</code>",
 "77": "<code>β✝</code>",
 "76":
 "<code>applyAtSecond {program : Type → Type → Type} {β γ α : Type} [Functional program] : (β → γ) → program (α × β) (α × γ)</code>",
 "75": "<code>α✝ → β</code>",
 "74": "<code>γ✝</code>",
 "73":
 "<code>applyAtFirst {program : Type → Type → Type} {α β γ : Type} [Functional program] : (α → β) → program (α × γ) (β × γ)</code>",
 "72": "<code>program γ δ</code>",
 "71": "<code>program β γ</code>",
 "70":
 "<code>LawfulSequential.sequential_associativity {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} [self : LawfulSequential program] {α β γ δ : Type} (αpβ : program α β)\n  (βpγ : program β γ) (γpδ : program γ δ) : (αpβ &gt;=&gt; βpγ &gt;=&gt; γpδ) = (αpβ &gt;=&gt; (βpγ &gt;=&gt; γpδ))</code>",
 "7":
 "<code>Functorial.andThenF {program : Type → Type → Type} [self : Functorial program] {α β γ : Type} :\n  program α β → (β → γ) → program α γ</code>",
 "69":
 "<code>LawfulSequential.sequential_left_identity {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} [self : LawfulSequential program] {α β : Type} (αpβ : program α β) :\n  (identity &gt;=&gt; αpβ) = αpβ</code>",
 "68":
 "<code>LawfulSequential.sequential_right_identity {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} [self : LawfulSequential program] {α β : Type} (αpβ : program α β) :\n  (αpβ &gt;=&gt; identity) = αpβ</code>",
 "67":
 "<code>LawfulSequential (program : Type → Type → Type) [Functional program] [Sequential program] : Prop</code>",
 "66": "<code>γ → δ</code>",
 "65":
 "<code>LawfulFunctorial.functorial_sequential {program : Type → Type → Type} {inst✝ : Functorial program}\n  [self : LawfulFunctorial program] {α β γ δ : Type} (αpβ : program α β) (βfγ : β → γ) (γfδ : γ → δ) :\n  (αpβ &gt;-&gt; βfγ &gt;-&gt; γfδ) = (αpβ &gt;-&gt; γfδ ∘ βfγ)</code>",
 "64":
 "<code>LawfulFunctorial.functorial_identity {program : Type → Type → Type} {inst✝ : Functorial program}\n  [self : LawfulFunctorial program] {α β : Type} (αpβ : program α β) : (αpβ &gt;-&gt; id) = αpβ</code>",
 "63":
 "<code>LawfulFunctorial (program : Type → Type → Type) [Functorial program] : Prop</code>",
 "62": "<code>α → β</code>",
 "61":
 "<code>LawfulFunctional.functional_sequential {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} [self : LawfulFunctional program] {α β γ : Type} (αfβ : α → β) (βfγ : β → γ) :\n  (asProgram αfβ &gt;=&gt; asProgram βfγ) = asProgram (βfγ ∘ αfβ)</code>",
 "60":
 "<code>LawfulFunctional.functional_identity {program : Type → Type → Type} {inst✝ : Functional program}\n  {inst✝¹ : Sequential program} [self : LawfulFunctional program] {α : Type} : asProgram id = identity</code>",
 "6": "<code>Functorial (program : Type → Type → Type) : Type 1</code>",
 "59":
 "<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "58":
 "<code>LawfulFunctional (program : Type → Type → Type) [Functional program] [Sequential program] : Prop</code>",
 "57":
 "<code>twiceMinusOne02 {program : Type → Type → Type} [Functional program] [Sequential program] [Creational program] :\n  program Nat Nat</code>",
 "56":
 "<code>twiceMinusOne01 {program : Type → Type → Type} [Functional program] [Functorial program] [Creational program] :\n  program Nat Nat</code>",
 "55": "<code>β → γ</code>",
 "54": "<code>{α β γ : Type} → program α β → (β → γ) → program α γ</code>",
 "53":
 "<code>factorial {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] : program Nat Nat</code>",
 "52":
 "<code>fibonacci {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] : program Nat Nat</code>",
 "51":
 "<code>multiply {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "50":
 "<code>add {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "5":
 "<code class=\"docstring\">Adds names from other namespaces to the current namespace.\n\nThe command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:\n\n- visible in the current namespace without prefix `Some.Namespace`, like `open`, and\n- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.\n\n## Examples\n\n```lean\nnamespace Morning.Sky\n  def star := \"venus\"\nend Morning.Sky\n\nnamespace Evening.Sky\n  export Morning.Sky (star)\n  -- `star` is now in scope\n  #check star\nend Evening.Sky\n\n-- `star` is visible in `Evening.Sky`\n#check Evening.Sky.star\n```\n</code>",
 "49":
 "<code>minusTwo {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "48":
 "<code>minusOne {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "47":
 "<code>one {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "46":
 "<code>isOne {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "45":
 "<code>isZero {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "44": "<code>multiplyF : Nat × Nat → Nat</code>",
 "43": "<code>addF : Nat × Nat → Nat</code>",
 "42": "<code>minusTwoF : Nat → Nat</code>",
 "41": "<code>minusOneF : Nat → Nat</code>",
 "40": "<code>oneF : Nat → Nat</code>",
 "4": "<code>Type</code>",
 "39": "<code>isOneF : Nat → Bool</code>",
 "38": "<code>Nat</code>",
 "37":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "36": "<code>isZeroF : Nat → Bool</code>",
 "35": "<code>else_.{u_1} {α : Sort u_1} : α → α</code>",
 "34":
 "<code>Sum.inr.{u, v} {α : Type u} {β : Type v} (val : β) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Right injection into the sum type `α ⊕ β`. </code>",
 "33":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "32":
 "<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>",
 "31":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "303":
 "<code>addAccumulatingSafeDivProduct {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat × Nat) Nat</code>",
 "302":
 "<code>accumulatingSafeDivProduct {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat × Nat) (Nat × Nat)</code>",
 "301":
 "<code>twiceAccumulatingSafeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat) Nat</code>",
 "300":
 "<code>accumulatingSafeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program (Nat × Nat) Bool</code>",
 "30": "<code>α✝</code>",
 "3":
 "<code>Functional.asProgram {program : Type → Type → Type} [self : Functional program] {α β : Type} : (α → β) → program α β</code>",
 "299":
 "<code>accumulatingSafeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program (Nat × Nat) Nat</code>",
 "298":
 "<code>materializeActiveWithValidation {ε : Type} [Monoid ε] {α β : Type} : ProgramWithValidation ε Active α β → α → ε ⊕ β</code>",
 "297":
 "<code>materializeWithValidation {computation : Type → Type} {ε : Type} [Monad computation] [Monoid ε] {α β : Type} :\n  ProgramWithValidation ε computation α β → α → computation (ε ⊕ β)</code>",
 "296":
 "<code>ProgramWithValidation (ε : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "295": "<code>ε</code>",
 "294": "<code>ε ⊕ (α✝ → β)</code>",
 "293": "<code>ε✝ ⊕ (α → β)</code>",
 "292": "<code>ε ⊕ (α → β)</code>",
 "291": "<code>ε ⊕ α</code>",
 "290": "<code>{α β : Type} → ε ⊕ α → ε ⊕ (α → β) → ε ⊕ β</code>",
 "29":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "289":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>",
 "288": "<code>Unit → FailureT ε computation α✝</code>",
 "287": "<code>computation (ε ⊕ (α✝ → β✝))</code>",
 "286":
 "<code>{α β : Type} → FailureT ε computation (α → β) → (Unit → FailureT ε computation α) → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "285":
 "<code>List.append.{u} {α : Type u} (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Appends two lists. Normally used via the `++` operator.\n\nAppending lists takes time proportional to the length of the first list: `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\n* `[] ++ [4, 5] = [4, 5]`.\n* `[1, 2, 3] ++ [] = [1, 2, 3]`.\n</code>",
 "284": "<code>List α → List α → List α</code>",
 "283": "<code>List α</code>",
 "282":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "281": "<code><span class=\"literal string\">\" * \"</span> : String</code>",
 "280": "<code>Monoid.combine {μ : Type} [self : Monoid μ] : μ → μ → μ</code>",
 "28": "<code>α × Bool</code>",
 "279": "<code>Monoid.ν {μ : Type} [self : Monoid μ] : μ</code>",
 "278": "<code>Monoid (μ : Type) : Type</code>",
 "277":
 "<code>twiceSafeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program ((Nat × Nat) × Nat) Nat</code>",
 "276":
 "<code>safeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program (Nat × Nat) Bool</code>",
 "275":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode code points.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "274":
 "<code>safeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program (Nat × Nat) Nat</code>",
 "273":
 "<code>unsafeDiv {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "272":
 "<code>isNotZero {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "271": "<code>unsafeDivF : Nat × Nat → Nat</code>",
 "270": "<code>isNotZeroF : Nat → Bool</code>",
 "27": "<code>program α Bool</code>",
 "269":
 "<code>materializeActiveWithFailure {ε α β : Type} : ProgramWithFailure ε Active α β → α → ε ⊕ β</code>",
 "268": "<code>α✝ → FailureT ε computation β</code>",
 "267":
 "<code>materializeWithFailure {computation : Type → Type} {ε : Type} [Monad computation] {α β : Type} :\n  ProgramWithFailure ε computation α β → α → computation (ε ⊕ β)</code>",
 "266":
 "<code>ProgramWithFailure (ε : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "265": "<code>α✝ → ε</code>",
 "264":
 "<code>{α β : Type} → (α → ε) → FromComputationValuedFunction (FailureT ε computation) α β</code>",
 "263": "<code>α✝ → FailureT ε computation β✝</code>",
 "262":
 "<code>{α β : Type} → FailureT ε computation α → (α → FailureT ε computation β) → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "261":
 "<code>{α : Type} → α → FailureT ε computation α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "260": "<code>ε✝</code>",
 "26":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "259": "<code>ε ⊕ α✝</code>",
 "258":
 "<code>FailureT.mk {ε : Type} {computation : Type → Type} {β : Type} (toComputationOfSum : computation (ε ⊕ β)) :\n  FailureT ε computation β</code>",
 "257": "<code>computation (ε ⊕ α✝)</code>",
 "256":
 "<code>{α β : Type} → (α → β) → FailureT ε computation α → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "255":
 "<code>FailureT.toComputationOfSum {ε : Type} {computation : Type → Type} {β : Type} (self : FailureT ε computation β) :\n  computation (ε ⊕ β)</code>",
 "254":
 "<code>FailureT (ε : Type) (computation : Type → Type) (β : Type) : Type</code>",
 "253":
 "<code>WithFailure.failureWith {ε : outParam Type} {program : Type → Type → Type} [self : WithFailure ε program] {α β : Type} :\n  (α → ε) → program α β</code>",
 "252":
 "<code>WithFailure (ε : outParam Type) (program : Type → Type → Type) : Type 1</code>",
 "251":
 "<code>fibonacciIncrementingArgumentPair {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState Nat program] : program Unit (Nat × Nat)</code>",
 "250":
 "<code>fibonacciIncrementingArgument {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState Nat program] : program Unit Nat</code>",
 "25":
 "<code>if_ {program : Type → Type → Type} {α β : Type} [Functional program] [Sequential program] [Creational program]\n  [Conditional program] : program α Bool → program α β → program α β → program α β</code>",
 "249":
 "<code>materializeActiveWithState {σ α β : Type} : ProgramWithState σ Active α β → α → σ → β</code>",
 "248": "<code>α✝ → StateT σ✝ computation β</code>",
 "247":
 "<code>StateT.run.{u, v} {σ : Type u} {m : Type u → Type v} {α : Type u} (x : StateT σ m α) (s : σ) : m (α × σ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n</code>",
 "246": "<code>σ✝</code>",
 "245": "<code>α → StateT σ computation β</code>",
 "244":
 "<code>materializeWithState {computation : Type → Type} {σ : Type} [Monad computation] {α β : Type} :\n  ProgramWithState σ computation α β → α → σ → computation β</code>",
 "243":
 "<code>StateT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a mutable state of type `σ` to a monad.\n\nActions in the resulting monad are functions that take an initial state and return, in `m`, a tuple\nof a value and a state.\n</code>",
 "242":
 "<code>ProgramWithState (σ : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "241":
 "<code>MonadStateOf.set.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} [self : MonadStateOf σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "240": "<code>FromComputationValuedFunction computation σ Unit</code>",
 "24": "<code>Sort u_1</code>",
 "239":
 "<code>MonadState.get.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "238":
 "<code>{α : Type} → FromComputationValuedFunction computation α σ</code>",
 "237":
 "<code>MonadStateOf.{u, v} (σ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadState σ` provides the same operations, but requires that `σ` be inferable from `m`.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "236": "<code>program σ τ</code>",
 "235":
 "<code>withInitialStateAsInitialValue {program : Type → Type → Type} {σ τ α : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState σ program] : program σ τ → program α τ</code>",
 "234": "<code>σ → σ</code>",
 "233":
 "<code>modifyStateWith {program : Type → Type → Type} {σ α : Type} [Functional program] [Sequential program]\n  [Creational program] [WithState σ program] : (σ → σ) → program α α</code>",
 "232":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "231":
 "<code>WithState.writeState {σ : outParam Type} {program : Type → Type → Type} [self : WithState σ program] : program σ Unit</code>",
 "230":
 "<code>WithState.readState {σ : outParam Type} {program : Type → Type → Type} [self : WithState σ program] {α : Type} :\n  program α σ</code>",
 "23": "<code>in_.{u_1} {α : Sort u_1} : α → α</code>",
 "229":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "228": "<code>outParam Type</code>",
 "227":
 "<code>WithState (σ : outParam Type) (program : Type → Type → Type) : Type 1</code>",
 "226":
 "<code>Unit.unit : Unit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the unit type.\n\nIt can be written as an empty tuple: `()`.\n</code>",
 "225":
 "<code>positionalSumOfFibonacciAndFactorial' {program : Type → Type → Type} {σ : Type} [Functional program]\n  [Creational program] [Sequential program] [Conditional program] : program (σ × Nat) ((((σ × Nat) × Nat) × Nat) × Nat)</code>",
 "224":
 "<code>positionalFactorialOfFibonacci' {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) (((σ × Nat) × Nat) × Nat)</code>",
 "223":
 "<code>positionalSumOfFibonacciAndFactorial {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) Nat</code>",
 "222":
 "<code>positionalFactorialOfFibonacci {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) Nat</code>",
 "221":
 "<code>positionOneAndTwo {program : Type → Type → Type} {σ β α : Type} [Functional program] : program ((σ × β) × α) (α × β)</code>",
 "220":
 "<code>positionTwo {program : Type → Type → Type} {σ β α : Type} [Functional program] : program ((σ × β) × α) β</code>",
 "22": "<code>program (α × β) γ</code>",
 "219":
 "<code>positionOne {program : Type → Type → Type} {σ α : Type} [Functional program] : program (σ × α) α</code>",
 "218": "<code>program σ α</code>",
 "217":
 "<code>{σ α β γ : Type} → program α β → program σ α → program (σ × β) γ → program σ γ</code>",
 "216": "<code><span class=\"literal string\">\" @ \"</span> : String</code>",
 "215":
 "<code>Positional.at_ {program : Type → Type → Type} [self : Positional program] {σ α β γ : Type} :\n  program α β → program σ α → program (σ × β) γ → program σ γ</code>",
 "214": "<code>Positional (program : Type → Type → Type) : Type 1</code>",
 "213":
 "<code>someProgram02 {program : Type → Type → Type} [Functional program] [Sequential program] [Creational program] :\n  program Nat Nat</code>",
 "212":
 "<code>someProgram01 {program : Type → Type → Type} [Functional program] [Functorial program] [Creational program] :\n  program Nat Nat</code>",
 "211":
 "<code>three {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "210":
 "<code>two {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "21": "<code>program α β</code>",
 "209": "<code>threeF : Nat → Nat</code>",
 "208": "<code>twoF : Nat → Nat</code>",
 "207": "<code>α✝ → ReactiveT β Active β</code>",
 "206":
 "<code>materializeReactive {α β : Type} : ReactiveProgram β Active α β → α → β</code>",
 "205":
 "<code>ReactiveProgram (ρ : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "204": "<code>α✝ → ReactiveT ρ computation β✝</code>",
 "203":
 "<code>{α β : Type} → ReactiveT ρ computation α → (α → ReactiveT ρ computation β) → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "202": "<code>Unit → ReactiveT ρ computation α✝</code>",
 "201": "<code>((α✝ → β✝) → computation ρ) → computation ρ</code>",
 "200":
 "<code>{α β : Type} → ReactiveT ρ computation (α → β) → (Unit → ReactiveT ρ computation α) → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "20":
 "<code>let_ {program : Type → Type → Type} {α β γ : Type} [Functional program] [Sequential program] [Creational program] :\n  program α β → program (α × β) γ → program α γ</code>",
 "2":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "199": "<code>α✝ → computation ρ</code>",
 "198":
 "<code>{α : Type} → α → ReactiveT ρ computation α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "197": "<code>β✝ → computation ρ</code>",
 "196":
 "<code>ReactiveT.mk {ρ : Type} {computation : Type → Type} {α : Type} (runReactiveT : (α → computation ρ) → computation ρ) :\n  ReactiveT ρ computation α</code>",
 "195": "<code>(α✝ → computation ρ) → computation ρ</code>",
 "194":
 "<code>{α β : Type} → (α → β) → ReactiveT ρ computation α → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "193": "<code>Reactive (ρ α : Type) : Type</code>",
 "192":
 "<code>ReactiveT.runReactiveT {ρ : Type} {computation : Type → Type} {α : Type} (self : ReactiveT ρ computation α) :\n  (α → computation ρ) → computation ρ</code>",
 "191":
 "<code>ReactiveT (ρ : Type) (computation : Type → Type) (α : Type) : Type</code>",
 "190":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "19":
 "<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "189":
 "<code>Id.run.{u_1} {α : Type u_1} (x : Id α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs a computation in the identity monad.\n\nThis function is the identity function. Because its parameter has type `Id α`, it causes\n`do`-notation in its arguments to use the `Monad Id` instance.\n</code>",
 "188": "<code>α✝ → Active β</code>",
 "187":
 "<code>materializeActive {α β : Type} : ActiveProgram α β → α → β</code>",
 "186": "<code>ActiveProgram (α β : Type) : Type</code>",
 "185":
 "<code>Id.{u} (type : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The identity function on types, used primarily for its `Monad` instance.\n\nThe identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with `do`-notation in order to use control structures such as\nlocal mutability, `for`-loops, and early returns in code that does not otherwise use monads.\n\nExamples:\n```lean example\ndef containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n```\n\n```lean example\n#eval containsFive [1, 3, 5, 7]\n```\n```output\ntrue\n```\n</code>",
 "184": "<code>Active.{u_1} (type : Type u_1) : Type u_1</code>",
 "183":
 "<code>creational_onlyFirst_assoc {computation : Type → Type} {α β γ δ : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) :\n  (onlyFirst (onlyFirst αpβ) &gt;=&gt; assoc) = (assoc &gt;=&gt; onlyFirst αpβ)</code>",
 "182":
 "<code>creational_onlyFirst_applyAtSecond {computation : Type → Type} {α β γ δ : Type} [Monad computation]\n  [LawfulMonad computation] (αpβ : FromComputationValuedFunction computation α β) (γfδ : γ → δ) :\n  (onlyFirst αpβ &gt;=&gt; applyAtSecond γfδ) = (applyAtSecond γfδ &gt;=&gt; onlyFirst αpβ)</code>",
 "181":
 "<code>creational_onlyFirst_first {computation : Type → Type} {α β γ : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (onlyFirst αpβ &gt;=&gt; first) = (first &gt;=&gt; αpβ)</code>",
 "180":
 "<code>creational_onlyFirst_sequential {computation : Type → Type} {δ α β γ : Type} [Monad computation]\n  [LawfulMonad computation] (αpβ : FromComputationValuedFunction computation α β)\n  (βpγ : FromComputationValuedFunction computation β γ) : onlyFirst (αpβ &gt;=&gt; βpγ) = (onlyFirst αpβ &gt;=&gt; onlyFirst βpγ)</code>",
 "18":
 "<code>identity {program : Type → Type → Type} {α : Type} [Functional program] : program α α</code>",
 "179":
 "<code>creational_onlyFirst_asProgram {computation : Type → Type} {α β γ : Type} [Monad computation] [LawfulMonad computation]\n  (αfβ : α → β) :\n  onlyFirst (asProgram αfβ) =\n    asProgram fun x =&gt;\n      match x with\n      | (α, γ_1) =&gt; (αfβ α, γ_1)</code>",
 "178":
 "<code>LawfulApplicative.pure_seq.{u, v} {f : Type u → Type v} {inst✝ : Applicative f} [self : LawfulApplicative f]\n  {α β : Type u} (g : α → β) (x : f α) : pure g &lt;*&gt; x = g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` before `seq` is equivalent to `Functor.map`.\n\nThis means that `pure` really is pure when occurring immediately prior to `seq`.\n</code>",
 "177":
 "<code>LawfulApplicative.map_pure.{u, v} {f : Type u → Type v} {inst✝ : Applicative f} [self : LawfulApplicative f]\n  {α β : Type u} (g : α → β) (x : α) : g &lt;$&gt; pure x = pure (g x)</code><span class=\"sep\"></span><code class=\"docstring\">Mapping a function over the result of `pure` is equivalent to applying the function under `pure`.\n\nThis means that `pure` really is pure with respect to `Functor.map`.\n</code>",
 "176": "<code>α✝ → computation (γ✝ → β × γ✝)</code>",
 "175": "<code>α → computation (γ → β × γ)</code>",
 "174": "<code>α✝¹ → β</code>",
 "173": "<code>α × γ</code>",
 "172":
 "<code>creational_onlyFirst_asProgram' {computation : Type → Type} {α β γ : Type} [Monad computation] [LawfulMonad computation]\n  (αfβ : α → β) :\n  onlyFirst (asProgram αfβ) =\n    asProgram fun x =&gt;\n      match x with\n      | (α, γ_1) =&gt; (αfβ α, γ_1)</code>",
 "171":
 "<code>sequential_associative {computation : Type → Type} {α β γ δ : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) (βpγ : FromComputationValuedFunction computation β γ)\n  (γpδ : FromComputationValuedFunction computation γ δ) : (αpβ &gt;=&gt; βpγ &gt;=&gt; γpδ) = (αpβ &gt;=&gt; (βpγ &gt;=&gt; γpδ))</code>",
 "170":
 "<code>LawfulMonad.bind_assoc.{u, v} {m : Type u → Type v} {inst✝ : Monad m} [self : LawfulMonad m] {α β γ : Type u} (x : m α)\n  (f : α → m β) (g : β → m γ) : x &gt;&gt;= f &gt;&gt;= g = x &gt;&gt;= fun x =&gt; f x &gt;&gt;= g</code><span class=\"sep\"></span><code class=\"docstring\">`bind` is associative.\n\nChanging the nesting of `bind` calls while maintaining the order of computations results in an\nequivalent computation. This means that `bind` is not doing more than data-dependent sequencing.\n</code>",
 "17": "<code><span class=\"literal string\">\" ||| \"</span> : String</code>",
 "169":
 "<code>Bind.bind.{u, v} {m : Type u → Type v} [self : Bind m] {α β : Type u} : m α → (α → m β) → m β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "168": "<code>β✝ → computation γ</code>",
 "167": "<code>β → computation δ</code>",
 "166": "<code>γ → computation δ</code>",
 "165": "<code>β → computation γ</code>",
 "164": "<code>FromComputationValuedFunction computation γ δ</code>",
 "163": "<code>FromComputationValuedFunction computation β γ</code>",
 "162":
 "<code>sequential_associative' {computation : Type → Type} {α β γ δ : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) (βpγ : FromComputationValuedFunction computation β γ)\n  (γpδ : FromComputationValuedFunction computation γ δ) : (αpβ &gt;=&gt; βpγ &gt;=&gt; γpδ) = (αpβ &gt;=&gt; (βpγ &gt;=&gt; γpδ))</code>",
 "161":
 "<code>sequential_left_identity {computation : Type → Type} {α β : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (asProgram id &gt;=&gt; αpβ) = αpβ</code>",
 "160":
 "<code>sequential_left_identity' {computation : Type → Type} {α β : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (asProgram id &gt;=&gt; αpβ) = αpβ</code>",
 "16":
 "<code>Conditional.sum {program : Type → Type → Type} [self : Conditional program] {α β γ : Type} :\n  program γ α → program β α → program (γ ⊕ β) α</code>",
 "159":
 "<code>sequential_right_identity {computation : Type → Type} {α β : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (αpβ &gt;=&gt; asProgram id) = αpβ</code>",
 "158":
 "<code>LawfulMonad.bind_pure_comp.{u, v} {m : Type u → Type v} {inst✝ : Monad m} [self : LawfulMonad m] {α β : Type u}\n  (f : α → β) (x : m α) :\n  (do\n      let a ← x\n      pure (f a)) =\n    f &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">A `bind` followed by `pure` composed with a function is equivalent to a functorial map.\n\nThis means that `pure` really is pure after a `bind` and has no effects.\n</code>",
 "157":
 "<code>sequential_right_identity' {computation : Type → Type} {α β : Type} [Monad computation] [LawfulMonad computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (αpβ &gt;=&gt; asProgram id) = αpβ</code>",
 "156":
 "<code>functorial_sequential {computation : Type → Type} {α β γ δ : Type} [Functor computation] [LawfulFunctor computation]\n  (αpβ : FromComputationValuedFunction computation α β) (βfγ : β → γ) (γfδ : γ → δ) :\n  (αpβ &gt;-&gt; βfγ &gt;-&gt; γfδ) = (αpβ &gt;-&gt; γfδ ∘ βfγ)</code>",
 "155":
 "<code>LawfulFunctor.comp_map.{u, v} {f : Type u → Type v} {inst✝ : Functor f} [self : LawfulFunctor f] {α β γ : Type u}\n  (g : α → β) (h : β → γ) (x : f α) : (h ∘ g) &lt;$&gt; x = h &lt;$&gt; g &lt;$&gt; x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves function composition.\n</code>",
 "154":
 "<code>Eq.symm.{u} {α : Sort u} {a b : α} (h : a = b) : b = a</code><span class=\"sep\"></span><code class=\"docstring\">Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "153": "<code>α✝¹ → computation β</code>",
 "152": "<code>α✝¹</code>",
 "151":
 "<code>functorial_sequential' {computation : Type → Type} {α β γ δ : Type} [Functor computation] [LawfulFunctor computation]\n  (αpβ : FromComputationValuedFunction computation α β) (βfγ : β → γ) (γfδ : γ → δ) :\n  (αpβ &gt;-&gt; βfγ &gt;-&gt; γfδ) = (αpβ &gt;-&gt; γfδ ∘ βfγ)</code>",
 "150":
 "<code>functorial_identity {computation : Type → Type} {α β : Type} [Functor computation] [LawfulFunctor computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (αpβ &gt;-&gt; id) = αpβ</code>",
 "15": "<code>Conditional (program : Type → Type → Type) : Type 1</code>",
 "149":
 "<code>LawfulFunctor.id_map.{u, v} {f : Type u → Type v} {inst✝ : Functor f} [self : LawfulFunctor f] {α : Type u} (x : f α) :\n  id &lt;$&gt; x = x</code><span class=\"sep\"></span><code class=\"docstring\">The `map` implementation preserves identity.\n</code>",
 "148": "<code>α✝ → computation β</code>",
 "147": "<code>α → computation β</code>",
 "146":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n</code>",
 "145": "<code>LawfulFunctor computation</code>",
 "144": "<code>Functor computation</code>",
 "143": "<code>FromComputationValuedFunction computation α β</code>",
 "142":
 "<code>LawfulFunctor.{u, v} (f : Type u → Type v) [Functor f] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A functor satisfies the functor laws.\n\nThe `Functor` class contains the operations of a functor, but does not require that instances\nprove they satisfy the laws of a functor. A `LawfulFunctor` instance includes proofs that the laws\nare satisfied. Because `Functor` instances may provide optimized implementations of `mapConst`,\n`LawfulFunctor` instances must also prove that the optimized implementation is equivalent to the\nstandard implementation.\n</code>",
 "141":
 "<code>functorial_identity' {computation : Type → Type} {α β : Type} [Functor computation] [LawfulFunctor computation]\n  (αpβ : FromComputationValuedFunction computation α β) : (αpβ &gt;-&gt; id) = αpβ</code>",
 "140":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "14": "<code><span class=\"literal string\">\" &&& \"</span> : String</code>",
 "139":
 "<code>functional_sequential {computation : Type → Type} {α β γ : Type} [Monad computation] [LawfulMonad computation]\n  (αfβ : α → β) (βfγ : β → γ) : (asProgram αfβ &gt;=&gt; asProgram βfγ) = asProgram (βfγ ∘ αfβ)</code>",
 "138":
 "<code>LawfulMonad.pure_bind.{u, v} {m : Type u → Type v} {inst✝ : Monad m} [self : LawfulMonad m] {α β : Type u} (x : α)\n  (f : α → m β) : pure x &gt;&gt;= f = f x</code><span class=\"sep\"></span><code class=\"docstring\">`pure` followed by `bind` is equivalent to function application.\n\nThis means that `pure` really is pure before a `bind` and has no effects.\n</code>",
 "137":
 "<code>funext.{u, v} {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x} (h : ∀ (x : α), f x = g x) : f = g</code><span class=\"sep\"></span><code class=\"docstring\">**Function extensionality.** If two functions return equal results for all possible arguments, then\nthey are equal.\n\nIt is called “extensionality” because it provides a way to prove two objects equal based on the\nproperties of the underlying mathematical functions, rather than based on the syntax used to denote\nthem. Function extensionality is a theorem that can be [proved using quotient\ntypes](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=quotient-funext).\n</code>",
 "136":
 "<code>congrArg.{u, v} {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β) (h : a₁ = a₂) : f a₁ = f a₂</code><span class=\"sep\"></span><code class=\"docstring\">Congruence in the function argument: if `a₁ = a₂` then `f a₁ = f a₂` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`&lt;something containing a₁&gt; = &lt;something containing a₂&gt;`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n</code>",
 "135":
 "<code>Function.comp.{u, v, w} {α : Sort u} {β : Sort v} {δ : Sort w} (f : β → δ) (g : α → β) : α → δ</code><span class=\"sep\"></span><code class=\"docstring\">Function composition, usually written with the infix operator `∘`. A new function is created from\ntwo existing functions, where one function's output is used as input to the other.\n\nExamples:\n * `Function.comp List.reverse (List.drop 2) [3, 2, 4, 1] = [1, 4]`\n * `(List.reverse ∘ List.drop 2) [3, 2, 4, 1] = [1, 4]`\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∘` in identifiers is `comp`.</code>",
 "134": "<code>LawfulMonad computation</code>",
 "133": "<code>Monad computation</code>",
 "132":
 "<code>LawfulMonad.{u, v} (m : Type u → Type v) [Monad m] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Lawful monads are those that satisfy a certain behavioral specification. While all instances of\n`Monad` should satisfy these laws, not all implementations are required to prove this.\n\n`LawfulMonad.mk'` is an alternative constructor that contains useful defaults for many fields.\n</code>",
 "131":
 "<code>functional_sequential' {computation : Type → Type} {α β γ : Type} [Monad computation] [LawfulMonad computation]\n  (αfβ : α → β) (βfγ : β → γ) : (asProgram αfβ &gt;=&gt; asProgram βfγ) = asProgram (βfγ ∘ αfβ)</code>",
 "130":
 "<code>rfl.{u} {α : Sort u} {a : α} : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, Lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nLean by `rfl`, because both sides are the same up to definitional equality.\n</code>",
 "13":
 "<code>Creational.product {program : Type → Type → Type} [self : Creational program] {α β γ : Type} :\n  program α β → program α γ → program α (β × γ)</code>",
 "129":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "128":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "127": "<code>Applicative computation</code>",
 "126":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "125":
 "<code>functional_identity {computation : Type → Type} {α : Type} [Applicative computation] : identity = asProgram id</code>",
 "124":
 "<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ←] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>",
 "123": "<code>β✝ → computation α✝</code>",
 "122": "<code>γ✝ → computation α✝</code>",
 "121":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation γ α →\n    FromComputationValuedFunction computation β α → FromComputationValuedFunction computation (γ ⊕ β) α</code>",
 "120": "<code>γ ⊕ β</code>",
 "12": "<code>Creational (program : Type → Type → Type) : Type 1</code>",
 "119": "<code>β → α</code>",
 "118": "<code>γ → α</code>",
 "117":
 "<code>foldSum {γ β α : Type} (γfα : γ → α) (βfα : β → α) (sum : γ ⊕ β) : α</code>",
 "116": "<code>β✝ → computation γ✝</code>",
 "115":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation α β →\n    FromComputationValuedFunction computation β γ → FromComputationValuedFunction computation α γ</code>",
 "114":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "113":
 "<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>",
 "112": "<code>α✝ → computation γ✝</code>",
 "111":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation α β →\n    FromComputationValuedFunction computation α γ → FromComputationValuedFunction computation α (β × γ)</code>",
 "110": "<code>β✝ → γ✝</code>",
 "11":
 "<code><span class=\"literal string\">\" &gt;=&gt; \"</span> : String</code>",
 "109": "<code>α✝ → computation β✝</code>",
 "108":
 "<code>{α β γ : Type} → FromComputationValuedFunction computation α β → (β → γ) → FromComputationValuedFunction computation α γ</code>",
 "107":
 "<code>Functor.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A functor in the sense used in functional programming, which means a function `f : Type u → Type v`\nhas a way of mapping a function over its contents. This `map` operator is written `&lt;$&gt;`, and\noverloaded via `Functor` instances.\n\nThis `map` function should respect identity and function composition. In other words, for all terms\n`v : f α`, it should be the case that:\n\n * `id &lt;$&gt; v = v`\n\n * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v`\n\nWhile all `Functor` instances should live up to these requirements, they are not required to _prove_\nthat they do. Proofs may be required or provided via the `LawfulFunctor` class.\n\nAssuming that instances are lawful, this definition corresponds to the category-theoretic notion of\n[functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the\ncategory of types and functions between them.\n</code>",
 "106":
 "<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "105":
 "<code>FromComputationValuedFunction.mk {computation : Type → Type} {α β : Type}\n  (toComputationValuedFunction : α → computation β) : FromComputationValuedFunction computation α β</code>",
 "104": "<code>α✝ → β✝</code>",
 "103":
 "<code>{α β : Type} → (α → β) → FromComputationValuedFunction computation α β</code>",
 "102":
 "<code>Applicative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An [applicative functor](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=monads-and-do) is more powerful than a `Functor`, but\nless powerful than a `Monad`.\n\nApplicative functors capture sequencing of effects with the `&lt;*&gt;` operator, overloaded as `seq`, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.\n\nApplicative functors should satisfy four laws. Instances of `Applicative` are not required to prove\nthat they satisfy these laws, which are part of the `LawfulApplicative` class.\n</code>",
 "101":
 "<code>FromComputationValuedFunction.toComputationValuedFunction {computation : Type → Type} {α β : Type}\n  (self : FromComputationValuedFunction computation α β) : α → computation β</code>",
 "100": "<code>Type → Type</code>",
 "10":
 "<code>Sequential.andThen {program : Type → Type → Type} [self : Sequential program] {α β γ : Type} :\n  program α β → program β γ → program α γ</code>",
 "1": "<code>Type → Type → Type</code>",
 "0": "<code>Functional (program : Type → Type → Type) : Type 1</code>"}