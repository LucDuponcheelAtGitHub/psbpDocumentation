{"99":
 "<code>ReactiveT.mk {ρ : Type} {computation : Type → Type} {α : Type} (runReactiveT : (α → computation ρ) → computation ρ) :\n  ReactiveT ρ computation α</code>",
 "98": "<code>(α✝ → computation ρ) → computation ρ</code>",
 "97":
 "<code>{α β : Type} → (α → β) → ReactiveT ρ computation α → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "96": "<code>Reactive (ρ α : Type) : Type</code>",
 "95":
 "<code>ReactiveT.runReactiveT {ρ : Type} {computation : Type → Type} {α : Type} (self : ReactiveT ρ computation α) :\n  (α → computation ρ) → computation ρ</code>",
 "94":
 "<code>ReactiveT (ρ : Type) (computation : Type → Type) (α : Type) : Type</code>",
 "93":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "92":
 "<code>Id.run.{u_1} {α : Type u_1} (x : Id α) : α</code><span class=\"sep\"></span><code class=\"docstring\">Runs a computation in the identity monad.\n\nThis function is the identity function. Because its parameter has type `Id α`, it causes\n`do`-notation in its arguments to use the `Monad Id` instance.\n</code>",
 "91": "<code>α✝ → Active β</code>",
 "90":
 "<code>materializeActive {α β : Type} : ActiveProgram α β → α → β</code>",
 "9": "<code>Creational (program : Type → Type → Type) : Type 1</code>",
 "89": "<code>ActiveProgram (α β : Type) : Type</code>",
 "88":
 "<code>Id.{u} (type : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The identity function on types, used primarily for its `Monad` instance.\n\nThe identity monad is useful together with monad transformers to construct monads for particular\npurposes. Additionally, it can be used with `do`-notation in order to use control structures such as\nlocal mutability, `for`-loops, and early returns in code that does not otherwise use monads.\n\nExamples:\n```lean example\ndef containsFive (xs : List Nat) : Bool := Id.run do\n  for x in xs do\n    if x == 5 then return true\n  return false\n```\n\n```lean example\n#eval containsFive [1, 3, 5, 7]\n```\n```output\ntrue\n```\n</code>",
 "87": "<code>Active.{u_1} (type : Type u_1) : Type u_1</code>",
 "86": "<code>β✝ → computation α✝</code>",
 "85": "<code>γ✝ → computation α✝</code>",
 "84":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation γ α →\n    FromComputationValuedFunction computation β α → FromComputationValuedFunction computation (γ ⊕ β) α</code>",
 "83": "<code>β</code>",
 "82": "<code>γ</code>",
 "81":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "80": "<code>γ ⊕ β</code>",
 "8":
 "<code><span class=\"literal string\">\" &gt;-&gt; \"</span> : String</code>",
 "79": "<code>β → α</code>",
 "78": "<code>γ → α</code>",
 "77":
 "<code>foldSum {γ β α : Type} (γfα : γ → α) (βfα : β → α) (sum : γ ⊕ β) : α</code>",
 "76": "<code>β✝ → computation γ✝</code>",
 "75":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation α β →\n    FromComputationValuedFunction computation β γ → FromComputationValuedFunction computation α γ</code>",
 "74":
 "<code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of\nsequential control flow and side effects used in functional programming. Monads allow both\nsequencing of effects and data-dependent effects: the values that result from an early step may\ninfluence the effects carried out in a later step.\n\nThe `Monad` API may be used directly. However, it is most commonly accessed through\n[`do`-notation](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=do-notation).\n\nMost `Monad` instances provide implementations of `pure` and `bind`, and use default implementations\nfor the other methods inherited from `Applicative`. Monads should satisfy certain laws, but\ninstances are not required to prove this. An instance of `LawfulMonad` expresses that a given\nmonad's operations are lawful.\n</code>",
 "73":
 "<code>Prod.mk.{u, v} {α : Type u} {β : Type v} (fst : α) (snd : β) : α × β</code><span class=\"sep\"></span><code class=\"docstring\">Constructs a pair. This is usually written `(x, y)` instead of `Prod.mk x y`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `(a, b)` in identifiers is `mk`.</code>",
 "72": "<code>α✝ → computation γ✝</code>",
 "71":
 "<code>{α β γ : Type} →\n  FromComputationValuedFunction computation α β →\n    FromComputationValuedFunction computation α γ → FromComputationValuedFunction computation α (β × γ)</code>",
 "70": "<code>β✝ → γ✝</code>",
 "7":
 "<code>Functorial.andThenF {program : Type → Type → Type} [self : Functorial program] {α β γ : Type} :\n  program α β → (β → γ) → program α γ</code>",
 "69": "<code>α✝ → computation β✝</code>",
 "68":
 "<code>{α β γ : Type} → FromComputationValuedFunction computation α β → (β → γ) → FromComputationValuedFunction computation α γ</code>",
 "67":
 "<code>Functor.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">A functor in the sense used in functional programming, which means a function `f : Type u → Type v`\nhas a way of mapping a function over its contents. This `map` operator is written `&lt;$&gt;`, and\noverloaded via `Functor` instances.\n\nThis `map` function should respect identity and function composition. In other words, for all terms\n`v : f α`, it should be the case that:\n\n * `id &lt;$&gt; v = v`\n\n * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) &lt;$&gt; v = h &lt;$&gt; g &lt;$&gt; v`\n\nWhile all `Functor` instances should live up to these requirements, they are not required to _prove_\nthat they do. Proofs may be required or provided via the `LawfulFunctor` class.\n\nAssuming that instances are lawful, this definition corresponds to the category-theoretic notion of\n[functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the\ncategory of types and functions between them.\n</code>",
 "66":
 "<code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "65":
 "<code>FromComputationValuedFunction.mk {computation : Type → Type} {α β : Type}\n  (toComputationValuedFunction : α → computation β) : FromComputationValuedFunction computation α β</code>",
 "64": "<code>α✝ → β✝</code>",
 "63":
 "<code>{α β : Type} → (α → β) → FromComputationValuedFunction computation α β</code>",
 "62":
 "<code>Applicative.{u, v} (f : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">An [applicative functor](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=monads-and-do) is more powerful than a `Functor`, but\nless powerful than a `Monad`.\n\nApplicative functors capture sequencing of effects with the `&lt;*&gt;` operator, overloaded as `seq`, but\nnot data-dependent effects. The results of earlier computations cannot be used to control later\neffects.\n\nApplicative functors should satisfy four laws. Instances of `Applicative` are not required to prove\nthat they satisfy these laws, which are part of the `LawfulApplicative` class.\n</code>",
 "61":
 "<code>FromComputationValuedFunction.toComputationValuedFunction {computation : Type → Type} {α β : Type}\n  (self : FromComputationValuedFunction computation α β) : α → computation β</code>",
 "60": "<code>Type → Type</code>",
 "6": "<code>Functorial (program : Type → Type → Type) : Type 1</code>",
 "59":
 "<code>FromComputationValuedFunction (computation : Type → Type) (α β : Type) : Type</code>",
 "58":
 "<code>twiceMinusOne02 {program : Type → Type → Type} [Functional program] [Sequential program] [Creational program] :\n  program Nat Nat</code>",
 "57":
 "<code>twiceMinusOne01 {program : Type → Type → Type} [Functional program] [Functorial program] [Creational program] :\n  program Nat Nat</code>",
 "56": "<code>β → γ</code>",
 "55": "<code>{α β γ : Type} → program α β → (β → γ) → program α γ</code>",
 "54":
 "<code>factorial {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] : program Nat Nat</code>",
 "53":
 "<code>fibonacci {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] : program Nat Nat</code>",
 "52":
 "<code>multiply {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "51":
 "<code>add {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "50":
 "<code>minusTwo {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "5":
 "<code class=\"docstring\">Adds names from other namespaces to the current namespace.\n\nThe command `export Some.Namespace (name₁ name₂)` makes `name₁` and `name₂`:\n\n- visible in the current namespace without prefix `Some.Namespace`, like `open`, and\n- visible from outside the current namespace `N` as `N.name₁` and `N.name₂`.\n\n## Examples\n\n```lean\nnamespace Morning.Sky\n  def star := \"venus\"\nend Morning.Sky\n\nnamespace Evening.Sky\n  export Morning.Sky (star)\n  -- `star` is now in scope\n  #check star\nend Evening.Sky\n\n-- `star` is visible in `Evening.Sky`\n#check Evening.Sky.star\n```\n</code>",
 "49":
 "<code>minusOne {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "48":
 "<code>one {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "47":
 "<code>isOne {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "46":
 "<code>isZero {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "45": "<code>multiplyF : Nat × Nat → Nat</code>",
 "44": "<code>addF : Nat × Nat → Nat</code>",
 "43": "<code>minusTwoF : Nat → Nat</code>",
 "42": "<code>minusOneF : Nat → Nat</code>",
 "41": "<code>oneF : Nat → Nat</code>",
 "40": "<code>isOneF : Nat → Bool</code>",
 "4": "<code>Type</code>",
 "39": "<code>Nat</code>",
 "38":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "37": "<code>isZeroF : Nat → Bool</code>",
 "36": "<code>else_.{u_1} {α : Sort u_1} : α → α</code>",
 "35": "<code>program α Bool</code>",
 "34":
 "<code>if_ {program : Type → Type → Type} {α β : Type} [Functional program] [Sequential program] [Creational program]\n  [Conditional program] : program α Bool → program α β → program α β → program α β</code>",
 "33":
 "<code>trueToLeftFalseToRight {program : Type → Type → Type} {α : Type} [Functional program] : program (α × Bool) (α ⊕ α)</code>",
 "32":
 "<code>Sum.inr.{u, v} {α : Type u} {β : Type v} (val : β) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Right injection into the sum type `α ⊕ β`. </code>",
 "31":
 "<code>Bool.false : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `false`, not to be confused with the proposition `False`. </code>",
 "30":
 "<code>Sum.inl.{u, v} {α : Type u} {β : Type v} (val : α) : α ⊕ β</code><span class=\"sep\"></span><code class=\"docstring\">Left injection into the sum type `α ⊕ β`. </code>",
 "3":
 "<code>Functional.asProgram {program : Type → Type → Type} [self : Functional program] {α β : Type} : (α → β) → program α β</code>",
 "29":
 "<code>Bool.true : Bool</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean value `true`, not to be confused with the proposition `True`. </code>",
 "28": "<code>α✝</code>",
 "27":
 "<code>Bool : Type</code><span class=\"sep\"></span><code class=\"docstring\">The Boolean values, `true` and `false`.\n\nLogically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is\npublic important for programming: both propositions and their proofs are erased in the code generator,\nwhile `Bool` corresponds to the Boolean type in most programming languages and carries precisely one\nbit of run-time information.\n</code>",
 "26": "<code>Type u_1</code>",
 "25":
 "<code>trueToLeftFalseToRightF.{u_1} {α : Type u_1} : α × Bool → α ⊕ α</code>",
 "24": "<code>Sort u_1</code>",
 "23": "<code>in_.{u_1} {α : Sort u_1} : α → α</code>",
 "22": "<code>program (α × β) γ</code>",
 "210":
 "<code>addAccumulatingSafeDivProduct {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat × Nat) Nat</code>",
 "21": "<code>program α β</code>",
 "209":
 "<code>accumulatingSafeDivProduct {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat × Nat) (Nat × Nat)</code>",
 "208":
 "<code>twiceAccumulatingSafeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithFailure (List String) program] : program ((Nat × Nat) × Nat) Nat</code>",
 "207":
 "<code>accumulatingSafeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program (Nat × Nat) Bool</code>",
 "206":
 "<code>accumulatingSafeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure (List String) program] : program (Nat × Nat) Nat</code>",
 "205":
 "<code>materializeActiveWithValidation {ε : Type} [Monoid ε] {α β : Type} : ProgramWithValidation ε Active α β → α → ε ⊕ β</code>",
 "204":
 "<code>materializeWithValidation {computation : Type → Type} {ε : Type} [Monad computation] [Monoid ε] {α β : Type} :\n  ProgramWithValidation ε computation α β → α → computation (ε ⊕ β)</code>",
 "203":
 "<code>ProgramWithValidation (ε : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "202": "<code>ε</code>",
 "201": "<code>α✝ → β</code>",
 "200": "<code>ε ⊕ (α✝ → β)</code>",
 "20":
 "<code>let_ {program : Type → Type → Type} {α β γ : Type} [Functional program] [Sequential program] [Creational program] :\n  program α β → program (α × β) γ → program α γ</code>",
 "2":
 "<code class=\"docstring\">A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. </code>",
 "199": "<code>ε✝ ⊕ (α → β)</code>",
 "198": "<code>ε ⊕ (α → β)</code>",
 "197": "<code>ε ⊕ α</code>",
 "196": "<code>{α β : Type} → ε ⊕ α → ε ⊕ (α → β) → ε ⊕ β</code>",
 "195":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>",
 "194": "<code>Unit → FailureT ε computation α✝</code>",
 "193": "<code>computation (ε ⊕ (α✝ → β✝))</code>",
 "192":
 "<code>{α β : Type} → FailureT ε computation (α → β) → (Unit → FailureT ε computation α) → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "191":
 "<code>List.append.{u} {α : Type u} (xs ys : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Appends two lists. Normally used via the `++` operator.\n\nAppending lists takes time proportional to the length of the first list: `O(|xs|)`.\n\nExamples:\n* `[1, 2, 3] ++ [4, 5] = [1, 2, 3, 4, 5]`.\n* `[] ++ [4, 5] = [4, 5]`.\n* `[1, 2, 3] ++ [] = [1, 2, 3]`.\n</code>",
 "190": "<code>List α → List α → List α</code>",
 "19":
 "<code>id.{u} {α : Sort u} (a : α) : α</code><span class=\"sep\"></span><code class=\"docstring\">The identity function. `id` takes an implicit argument `α : Sort u`\n(a type in any universe), and an argument `a : α`, and returns `a`.\n\nAlthough this may look like a useless function, one application of the identity\nfunction is to explicitly put a type on an expression. If `e` has type `T`,\nand `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean\nknows that this expression has type `T'` rather than `T`. This can make a\ndifference for typeclass inference, since `T` and `T'` may have different\ntypeclass instances on them. `show T' from e` is sugar for an `@id T' e`\nexpression.\n</code>",
 "189": "<code>List α</code>",
 "188":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "187": "<code><span class=\"literal string\">\" * \"</span> : String</code>",
 "186": "<code>Monoid.combine {μ : Type} [self : Monoid μ] : μ → μ → μ</code>",
 "185": "<code>Monoid.ν {μ : Type} [self : Monoid μ] : μ</code>",
 "184": "<code>Monoid (μ : Type) : Type</code>",
 "183":
 "<code>twiceSafeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program ((Nat × Nat) × Nat) Nat</code>",
 "182":
 "<code>safeDivIsOne {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program (Nat × Nat) Bool</code>",
 "181":
 "<code>String : Type</code><span class=\"sep\"></span><code class=\"docstring\">A string is a sequence of Unicode code points.\n\nAt runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array)\nof bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters\n(`String.length`) are cached and take constant time. Many operations on strings perform in-place\nmodifications when the reference to the string is unique.\n</code>",
 "180":
 "<code>safeDiv {program : Type → Type → Type} [Functional program] [Creational program] [Sequential program]\n  [Conditional program] [WithFailure String program] : program (Nat × Nat) Nat</code>",
 "18":
 "<code>identity {program : Type → Type → Type} {α : Type} [Functional program] : program α α</code>",
 "179":
 "<code>unsafeDiv {program : Type → Type → Type} [Functional program] : program (Nat × Nat) Nat</code>",
 "178":
 "<code>isNotZero {program : Type → Type → Type} [Functional program] : program Nat Bool</code>",
 "177": "<code>unsafeDivF : Nat × Nat → Nat</code>",
 "176": "<code>isNotZeroF : Nat → Bool</code>",
 "175":
 "<code>materializeActiveWithFailure {ε α β : Type} : ProgramWithFailure ε Active α β → α → ε ⊕ β</code>",
 "174": "<code>α✝ → FailureT ε computation β</code>",
 "173":
 "<code>materializeWithFailure {computation : Type → Type} {ε : Type} [Monad computation] {α β : Type} :\n  ProgramWithFailure ε computation α β → α → computation (ε ⊕ β)</code>",
 "172":
 "<code>ProgramWithFailure (ε : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "171": "<code>α✝ → ε</code>",
 "170":
 "<code>{α β : Type} → (α → ε) → FromComputationValuedFunction (FailureT ε computation) α β</code>",
 "17": "<code><span class=\"literal string\">\" ||| \"</span> : String</code>",
 "169": "<code>α✝ → FailureT ε computation β✝</code>",
 "168":
 "<code>{α β : Type} → FailureT ε computation α → (α → FailureT ε computation β) → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "167":
 "<code>{α : Type} → α → FailureT ε computation α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "166": "<code>ε✝</code>",
 "165": "<code>ε ⊕ α✝</code>",
 "164":
 "<code>FailureT.mk {ε : Type} {computation : Type → Type} {β : Type} (toComputationOfSum : computation (ε ⊕ β)) :\n  FailureT ε computation β</code>",
 "163": "<code>computation (ε ⊕ α✝)</code>",
 "162":
 "<code>{α β : Type} → (α → β) → FailureT ε computation α → FailureT ε computation β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function inside a functor. This is used to overload the `&lt;$&gt;` operator.\n\nWhen mapping a constant function, use `Functor.mapConst` instead, because it may be more\nefficient.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;$&gt;` in identifiers is `map`.</code>",
 "161":
 "<code>FailureT.toComputationOfSum {ε : Type} {computation : Type → Type} {β : Type} (self : FailureT ε computation β) :\n  computation (ε ⊕ β)</code>",
 "160":
 "<code>FailureT (ε : Type) (computation : Type → Type) (β : Type) : Type</code>",
 "16":
 "<code>Conditional.sum {program : Type → Type → Type} [self : Conditional program] {α β γ : Type} :\n  program γ α → program β α → program (γ ⊕ β) α</code>",
 "159":
 "<code>WithFailure.failureWith {ε : outParam Type} {program : Type → Type → Type} [self : WithFailure ε program] {α β : Type} :\n  (α → ε) → program α β</code>",
 "158":
 "<code>WithFailure (ε : outParam Type) (program : Type → Type → Type) : Type 1</code>",
 "157":
 "<code>fibonacciIncrementingArgumentPair {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState Nat program] : program Unit (Nat × Nat)</code>",
 "156":
 "<code>fibonacciIncrementingArgument {program : Type → Type → Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState Nat program] : program Unit Nat</code>",
 "155":
 "<code>materializeActiveWithState {σ α β : Type} : ProgramWithState σ Active α β → α → σ → β</code>",
 "154": "<code>α✝ → StateT σ✝ computation β</code>",
 "153":
 "<code>StateT.run.{u, v} {σ : Type u} {m : Type u → Type v} {α : Type u} (x : StateT σ m α) (s : σ) : m (α × σ)</code><span class=\"sep\"></span><code class=\"docstring\">Executes an action from a monad with added state in the underlying monad `m`. Given an initial\nstate, it returns a value paired with the final state.\n</code>",
 "152": "<code>σ✝</code>",
 "151": "<code>α → StateT σ computation β</code>",
 "150":
 "<code>materializeWithState {computation : Type → Type} {σ : Type} [Monad computation] {α β : Type} :\n  ProgramWithState σ computation α β → α → σ → computation β</code>",
 "15": "<code>Conditional (program : Type → Type → Type) : Type 1</code>",
 "149":
 "<code>StateT.{u, v} (σ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a mutable state of type `σ` to a monad.\n\nActions in the resulting monad are functions that take an initial state and return, in `m`, a tuple\nof a value and a state.\n</code>",
 "148":
 "<code>ProgramWithState (σ : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "147":
 "<code>MonadStateOf.set.{u, v} {σ : semiOutParam (Type u)} {m : Type u → Type v} [self : MonadStateOf σ m] : σ → m PUnit</code><span class=\"sep\"></span><code class=\"docstring\">Replaces the current value of the mutable state with a new one.\n</code>",
 "146": "<code>FromComputationValuedFunction computation σ Unit</code>",
 "145":
 "<code>MonadState.get.{u, v} {σ : outParam (Type u)} {m : Type u → Type v} [self : MonadState σ m] : m σ</code><span class=\"sep\"></span><code class=\"docstring\">Retrieves the current value of the monad's mutable state.\n</code>",
 "144":
 "<code>{α : Type} → FromComputationValuedFunction computation α σ</code>",
 "143":
 "<code>MonadStateOf.{u, v} (σ : semiOutParam (Type u)) (m : Type u → Type v) : Type (max (u + 1) v)</code><span class=\"sep\"></span><code class=\"docstring\">State monads provide a value of a given type (the _state_) that can be retrieved or replaced.\nInstances may implement these operations by passing state values around, by using a mutable\nreference cell (e.g. `ST.Ref σ`), or in other ways.\n\nIn this class, `σ` is a `semiOutParam`, which means that it can influence the choice of instance.\n`MonadState σ` provides the same operations, but requires that `σ` be inferable from `m`.\n\nThe mutable state of a state monad is visible between multiple `do`-blocks or functions, unlike\n[local mutable state](https://lean-lang.org/doc/reference/4.22.0-rc4/find/?domain=Verso.Genre.Manual.section&name=do-notation-let-mut) in `do`-notation.\n</code>",
 "142": "<code>program σ τ</code>",
 "141":
 "<code>withInitialStateAsInitialValue {program : Type → Type → Type} {σ τ α : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] [WithState σ program] : program σ τ → program α τ</code>",
 "140": "<code>σ → σ</code>",
 "14":
 "<code><span class=\"literal string\">\" &gt;=&gt; \"</span> : String</code>",
 "139":
 "<code>modifyStateWith {program : Type → Type → Type} {σ α : Type} [Functional program] [Sequential program]\n  [Creational program] [WithState σ program] : (σ → σ) → program α α</code>",
 "138":
 "<code>second {program : Type → Type → Type} {α β : Type} [Functional program] : program (α × β) β</code>",
 "137":
 "<code>first {program : Type → Type → Type} {α β : Type} [Functional program] : program (α × β) α</code>",
 "136":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "135":
 "<code>WithState.writeState {σ : outParam Type} {program : Type → Type → Type} [self : WithState σ program] : program σ Unit</code>",
 "134":
 "<code>WithState.readState {σ : outParam Type} {program : Type → Type → Type} [self : WithState σ program] {α : Type} :\n  program α σ</code>",
 "133":
 "<code>outParam.{u} (α : Sort u) : Sort u</code><span class=\"sep\"></span><code class=\"docstring\">Gadget for marking output parameters in type classes.\n\nFor example, the `Membership` class is defined as:\n```\nclass Membership (α : outParam (Type u)) (γ : Type v)\n```\nThis means that whenever a typeclass goal of the form `Membership ?α ?γ` comes\nup, Lean will wait to solve it until `?γ` is known, but then it will run\ntypeclass inference, and take the first solution it finds, for any value of `?α`,\nwhich thereby determines what `?α` should be.\n\nThis expresses that in a term like `a ∈ s`, `s` might be a `Set α` or\n`List α` or some other type with a membership operation, and in each case\nthe \"member\" type `α` is determined by looking at the container type.\n</code>",
 "132": "<code>outParam Type</code>",
 "131":
 "<code>WithState (σ : outParam Type) (program : Type → Type → Type) : Type 1</code>",
 "130":
 "<code>Unit.unit : Unit</code><span class=\"sep\"></span><code class=\"docstring\">The only element of the unit type.\n\nIt can be written as an empty tuple: `()`.\n</code>",
 "13":
 "<code>Sequential.andThen {program : Type → Type → Type} [self : Sequential program] {α β γ : Type} :\n  program α β → program β γ → program α γ</code>",
 "129":
 "<code>positionalSumOfFibonacciAndFactorial' {program : Type → Type → Type} {σ : Type} [Functional program]\n  [Creational program] [Sequential program] [Conditional program] : program (σ × Nat) ((((σ × Nat) × Nat) × Nat) × Nat)</code>",
 "128":
 "<code>positionalFactorialOfFibonacci' {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) (((σ × Nat) × Nat) × Nat)</code>",
 "127":
 "<code>positionalSumOfFibonacciAndFactorial {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) Nat</code>",
 "126":
 "<code>positionalFactorialOfFibonacci {program : Type → Type → Type} {σ : Type} [Functional program] [Creational program]\n  [Sequential program] [Conditional program] : program (σ × Nat) Nat</code>",
 "125":
 "<code>positionOneAndTwo {program : Type → Type → Type} {σ β α : Type} [Functional program] : program ((σ × β) × α) (α × β)</code>",
 "124": "<code>β✝</code>",
 "123":
 "<code>positionTwo {program : Type → Type → Type} {σ β α : Type} [Functional program] : program ((σ × β) × α) β</code>",
 "122":
 "<code>positionOne {program : Type → Type → Type} {σ α : Type} [Functional program] : program (σ × α) α</code>",
 "121": "<code>program σ α</code>",
 "120":
 "<code>{σ α β γ : Type} → program α β → program σ α → program (σ × β) γ → program σ γ</code>",
 "12": "<code>Sequential (program : Type → Type → Type) : Type 1</code>",
 "119": "<code><span class=\"literal string\">\" @ \"</span> : String</code>",
 "118":
 "<code>Positional.at_ {program : Type → Type → Type} [self : Positional program] {σ α β γ : Type} :\n  program α β → program σ α → program (σ × β) γ → program σ γ</code>",
 "117": "<code>Positional (program : Type → Type → Type) : Type 1</code>",
 "116":
 "<code>someProgram02 {program : Type → Type → Type} [Functional program] [Sequential program] [Creational program] :\n  program Nat Nat</code>",
 "115":
 "<code>someProgram01 {program : Type → Type → Type} [Functional program] [Functorial program] [Creational program] :\n  program Nat Nat</code>",
 "114":
 "<code>three {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "113":
 "<code>two {program : Type → Type → Type} [Functional program] : program Nat Nat</code>",
 "112": "<code>threeF : Nat → Nat</code>",
 "111": "<code>twoF : Nat → Nat</code>",
 "110": "<code>α✝ → ReactiveT β Active β</code>",
 "11": "<code><span class=\"literal string\">\" &&& \"</span> : String</code>",
 "109":
 "<code>materializeReactive {α β : Type} : ReactiveProgram β Active α β → α → β</code>",
 "108":
 "<code>ReactiveProgram (ρ : Type) (computation : Type → Type) (α β : Type) : Type</code>",
 "107": "<code>α✝ → ReactiveT ρ computation β✝</code>",
 "106":
 "<code>{α β : Type} → ReactiveT ρ computation α → (α → ReactiveT ρ computation β) → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">Sequences two computations, allowing the second to depend on the value computed by the first.\n\nIf `x : m α` and `f : α → m β`, then `x &gt;&gt;= f : m β` represents the result of executing `x` to get\na value of type `α` and then passing it to `f`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&gt;&gt;=` in identifiers is `bind`.</code>",
 "105": "<code>Unit → ReactiveT ρ computation α✝</code>",
 "104": "<code>((α✝ → β✝) → computation ρ) → computation ρ</code>",
 "103":
 "<code>{α β : Type} → ReactiveT ρ computation (α → β) → (Unit → ReactiveT ρ computation α) → ReactiveT ρ computation β</code><span class=\"sep\"></span><code class=\"docstring\">The implementation of the `&lt;*&gt;` operator.\n\nIn a monad, `mf &lt;*&gt; mx` is the same as `do let f ← mf; x ← mx; pure (f x)`: it evaluates the\nfunction first, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a `Unit → f α` function.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `&lt;*&gt;` in identifiers is `seq`.</code>",
 "102": "<code>α✝ → computation ρ</code>",
 "101":
 "<code>{α : Type} → α → ReactiveT ρ computation α</code><span class=\"sep\"></span><code class=\"docstring\">Given `a : α`, then `pure a : f α` represents an action that does nothing and returns `a`.\n\nExamples:\n* `(pure \"hello\" : Option String) = some \"hello\"`\n* `(pure \"hello\" : Except (Array String) String) = Except.ok \"hello\"`\n* `(pure \"hello\" : StateM Nat String).run 105 = (\"hello\", 105)`\n</code>",
 "100": "<code>β✝ → computation ρ</code>",
 "10":
 "<code>Creational.product {program : Type → Type → Type} [self : Creational program] {α β γ : Type} :\n  program α β → program α γ → program α (β × γ)</code>",
 "1": "<code>Type → Type → Type</code>",
 "0": "<code>Functional (program : Type → Type → Type) : Type 1</code>"}